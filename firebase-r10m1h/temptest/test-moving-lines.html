<head>
    <!-- for MWC, https://github.com/material-components/material-web -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
    <link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Material+Icons&amp;display=block" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

    <!-- Required styles for Material Web -->
    <link rel="stylesheet" href="https://unpkg.com/material-components-web@latest/dist/material-components-web.css">
    <script src="http://localhost:8080/public/ext/mdc/material-components-web.js"></script>
    <!-- <script src="//:8080/public/ext/mdc/material-components-web.js"></script> -->
    <!-- <script src="/src/js/error.js"></script> -->

    <link rel="stylesheet" href="http://localhost:8080/public/css/rem10m1h.css">
    <style>
        :root {
            --icon-button-size: 48;
        }
    </style>

    <script type="importmap">
        {
          "imports": {
            "util-mdc": "http://localhost:8080/public/src/js/mod/util-mdc.js"
          }
        }
    </script>
    <script src="../public/src/js/error.js"></script>
    <!-- <script src="../public/src/js/mod/util-mdc.js"></script> -->
    <script>
        if (location.href != "http://localhost:8080/temptest/test-moving-lines.html") throw Error("run http-server . in firebase-r10m1h");
        let eltCanvas;
        let ctxCanvas;
        let bcrCanvas

        let currentPointY = 0;
        let middleX;

        const currentPointCanvas = {
            cX: undefined,
            cY: undefined,
        }

        function drawCurrentPoint(color) {
            // const cX = pattX2canvasX(middleX);
            // const cY = pattY2canvasY(currentPointY);
            const cX = currentPointCanvas.cX;
            const cY = currentPointCanvas.cY;
            // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/ellipse
            // const cR = pattY2canvasY(0) / 20;
            const cR = currentPointCanvas.cR;
            ctxCanvas.beginPath();
            ctxCanvas.ellipse(cX, cY, cR, cR, 0, 0, 2 * Math.PI);
            ctxCanvas.strokeStyle = "darkgoldenrod";
            // ctxCanvas.strokeWidth = 2;
            ctxCanvas.lineWidth = cR * 2.0;
            ctxCanvas.fillStyle = color;
            ctxCanvas.stroke();
            ctxCanvas.fill();
        }



        const breathPatterns = {
            "Awake": makeBreathPattern(6, 0, 2, 0),
            "Square": makeBreathPattern(4, 4, 4, 4),
            "Deep Calm": makeBreathPattern(4, 7, 8, 0),
            "Pranayama": makeBreathPattern(7, 4, 8, 4),
            "Ujjayi": makeBreathPattern(7, 0, 7, 0),
            "Custom Exercis": makeBreathPattern(2, 4, 3, 5),
        }
        let currentPattern = "Pranayama";

        function tellCurrentPattern() {
            const divPatternInfo = document.getElementById("elt-pattern-info");
            divPatternInfo.textContent = "";
            const eltName = mkElt("span", undefined, currentPattern);
            eltName.style = `
                    font-weight: bold;
                    margin-right: 10px;
                `;
            divPatternInfo.appendChild(eltName);
            // const p = breathPatterns[currentPattern].patt;
            // const strPatt = `${p.breathIn}-${p.holdHigh}-${p.breathOut}-${p.holdLow}`;
            const strPatt = mkPattString(currentPattern);
            const eltPatt = mkElt("span", undefined, strPatt);
            divPatternInfo.appendChild(eltPatt);
            // debugger;
        }

        function initCurrentPattern() {
            document.documentElement.classList.remove("running");
            isRunning = false;
            msStart = document.timeline.currentTime;
            tellInitialState();
            redraw();
        }


        function mkPattString(pattName) {
            const p = breathPatterns[pattName].patt;
            const strPatt = `(${p.breathIn}-${p.holdHigh}-${p.breathOut}-${p.holdLow})`;
            return strPatt;
        }

        async function dialogPattern() {
            const modMdc = await import("util-mdc");
            const divPattList = mkElt("div");
            divPattList.style = `
                    display: flex;
                    flex-direction: column;
                    gap: 10px;
                `;
            const funHandleResult = () => {
                const rad = divPattList.querySelector("input[name=pattName]:checked");
                return { pattName: rad.value };
            };

            const bdy = mkElt("div", undefined, [
                mkElt("h2", undefined, "Breathing pattern"),
                divPattList,
            ]);
            bdy.id = "dialog-pattern";
            bdy.classList.add("colored-dialog");
            for (const pn in breathPatterns) {
                console.log({ pn });
                const rad = mkElt("input", { type: "radio", name: "pattName", value: pn });
                if (currentPattern == pn) rad.checked = true;
                const eltName = mkElt("b", undefined, pn);
                eltName.style = `margin-right: 5px; margin-left: 5px;`;
                const eltInfo = mkElt("span", undefined, [eltName, mkPattString(pn)]);
                // eltInfo.style = ` display: flex; gap: 5px; `;
                // const lbl = mkElt("label", undefined, [rad, pn]);
                const lbl = mkElt("label", undefined, [rad, eltInfo]);
                divPattList.appendChild(lbl);
            }
            const { pattName } = await modMdc.mkMDCdialogConfirm(bdy, "Save",
                undefined, undefined,
                funHandleResult,
                // tellMeOkButton,
            );
            currentPattern = pattName || currentPattern;
            tellCurrentPattern();
            initCurrentPattern();
        }

        let stopRedraw = false;
        let numChecks = 0;
        const textForParts = {
            holdLow: "Hold...",
            breathIn: "Inhale",
            holdHigh: "Hold...",
            breathOut: "Exhale",
        }
        function makeBreathPattern(breathIn, holdHigh, breathOut, holdLow) {
            const pattY = {
                holdLow: 0,
                breathIn: 0,
                holdHigh: 1,
                breathOut: 1,
            }
            const patt = {
                holdLow,
                breathIn,
                holdHigh,
                breathOut,
            }
            for (const k in patt) {
                const v = patt[k];
                if (isNaN(v)) throw Error(`Value for ${k} is not numeric: ${v}`);
                // if (v <= 0) throw Error(`Value for ${k} is not positive: ${v}`);
                if (v < 0) throw Error(`Value for ${k} is too small: ${v}`);
                if (v >= 10) throw Error(`Value for ${k} is too big: ${v}`);
            }
            const pattW = Object.values(patt)
                .reduce((acc, next) => acc = acc + next, 0);
            const pattPoints = [];
            let pointY;
            let pointX = 0;
            for (part in patt) {
                pointY = pattY[part];
                pattPoints.push({ pointX, pointY, part });
                const diffX = patt[part];
                pointX += diffX;
            }
            console.log({ pattPoints });
            return {
                patt,
                pattW,
                pattPoints
            };
        }

        let msLastDraw;
        let pxPerMs;
        // const msStart = Date.now();
        let msStart = document.timeline.currentTime;
        let canvasSec;

        function tellState(txtState, hideIt) {
            const divInstructions = document.getElementById("elt-instructions");
            divInstructions.textContent = txtState;
            if (hideIt) {
                divInstructions.style.visibility = "hidden";
            } else {
                divInstructions.style.visibility = null;
            }
        }
        function tellInitialState() {
            // tellState(`Current pattern: ${currentPattern}`);
            tellState("Not started ", true);
        }

        function drawPattern(patt, numPatt) {
            bcrCanvas = eltCanvas.getBoundingClientRect();
            eltCanvas.width = bcrCanvas.width;
            eltCanvas.height = bcrCanvas.height;
            ctxCanvas.clearRect(0, 0, eltCanvas.width, eltCanvas.height);

            const points = patt.pattPoints;
            canvasSec = patt.pattW * numPatt;

            ctxCanvas.beginPath();

            ctxCanvas.lineWidth = 5;
            ctxCanvas.lineCap = "round"; // FIX-ME: does not work?? Bug???
            ctxCanvas.strokeStyle = "yellowgreen";

            // msLastDraw = Date.now();
            msLastDraw = document.timeline.currentTime;

            const p0 = points[0];
            moveTo(p0);
            let protect = 0;
            let lastCanvasX = true;
            let lastPoint;
            middleX = numPatt * patt.pattW / 2;
            const middleCanvasX = pattX2canvasX(middleX);
            let middleY = 0.2;
            while (protect++ < 5 && lastCanvasX) {
                for (let i = 0, len = points.length; i < len; i++) {
                    const pnt = points[i];
                    const nextPoint = { ...pnt }
                    nextPoint.pointX = pnt.pointX + (protect - 1) * patt.pattW;
                    // if (nextPoint.pointX <= lastX) debugger;
                    // lastX = nextX;

                    const nextCanvasX = lineTo(nextPoint);
                    if (!nextCanvasX) break;

                    if (lastCanvasX < middleCanvasX && middleCanvasX <= nextCanvasX) {
                        if (!lastPoint) {
                            middleY = 0;
                        } else {
                            const lastY = lastPoint.pointY;
                            const nextY = nextPoint.pointY;
                            const part = (middleCanvasX - lastCanvasX) / (nextCanvasX - lastCanvasX);
                            middleY = lastY + (nextY - lastY) * part;
                            // eltIn.textContent = lastPoint.part;
                            const txtState = textForParts[lastPoint.part];
                            tellState(txtState);
                        }
                    }

                    lastPoint = nextPoint;
                    lastCanvasX = nextCanvasX;
                }
            }
            ctxCanvas.stroke();
            currentPointY = middleY;
            const clrPoint = isRunning ? "yellow" : "yellowgreen";

            currentPointCanvas.cX = pattX2canvasX(middleX);
            currentPointCanvas.cY = pattY2canvasY(currentPointY);
            currentPointCanvas.cR = pattY2canvasY(0) / 30;
            drawCurrentPoint(clrPoint);
            function moveTo(pnt) {
                const pntCanvas = pnt2canvas(pnt);
                ctxCanvas.moveTo(pntCanvas.x, pntCanvas.y);
            }
            function lineTo(pnt) {
                // console.log("lineTo", pnt);
                const pntCanvas = pnt2canvas(pnt);
                ctxCanvas.lineTo(pntCanvas.x, pntCanvas.y);
                if (pntCanvas.x < eltCanvas.width) {
                    return pntCanvas.x; // So we don't have to calculate it again...
                }
                return false;
            }
            function pnt2canvas(pnt) {
                const sec = (msLastDraw - msStart) / 1000;
                const x = pnt.pointX - sec + canvasSec / 2;
                const pntC = {
                    x: pattX2canvasX(x),
                    y: pattY2canvasY(pnt.pointY),
                }
                // console.log({ pntC });
                return pntC;
            }
            function mkPxPerMs() {
                pxPerMs = bcrCanvas.width / (patt.pattW * numPatt);
            }
            function pattX2canvasX(pattX) {
                const msElapsed = msLastDraw - msStart;
                const msInpattern = msElapsed % Math.floor(patt.pattW * 1000);
                // const currX = pattX - msInpattern / 1000;
                const currX = pattX - msElapsed / 1000;
                mkPxPerMs();
                // return pattX / (patt.pattW * numPatt) * bcrCanvas.width;
                // return bcrCanvas.width * pattX / (patt.pattW * numPatt);
                // return pattX * bcrCanvas.width / (patt.pattW * numPatt);
                return pattX * pxPerMs;
                return currX * pxPerMs;
            }
            function pattY2canvasY(pattY) {
                const bottom = bcrCanvas.height * 0.2;
                const top = bcrCanvas.height * 0.2;
                const height = bcrCanvas.height - top - bottom;
                const invertY = Math.abs(pattY - 1);
                // return pattY * height + top;
                return invertY * height + top;
            }
        }
        function setupCanvas(container) {
            // const container = document.body;
            // eltCanvas = document.getElementById("my-canvas");
            eltCanvas = document.createElement("canvas");
            container.appendChild(eltCanvas)
            // eltCanvas.id = "my-canvas";


            //// Images that can be used. Copyright??? Ask user?
            let srPreset;
            srPreset = "256x144";
            srPreset = "1012x576";
            srPreset = "512x288";
            const availableImages = {
                //////// SR generell
                // ?format=webp&preset=${srPreset}`,
                //// Flowers
                srRedFlower:
                    `https://static-cdn.sr.se/images/2689/995b2007-ad8d-4b6f-8b6c-5fc105d84831.jpg?format=webp&preset=${srPreset}`,
                srYellowFlower:
                    `https://static-cdn.sr.se/images/2689/8b2c6f4f-a143-4dd4-85c5-be23f5c26aad.jpg?format=webp&preset=${srPreset}`,

                //////// SR Veckans bild
                // https://sverigesradio.se/grupp/25727
                srFlowerAndBees:
                    `https://static-cdn.sr.se/images/78/8d578df3-5bfa-4fad-9a72-44a99234f8ff.jpg?format=webp&preset=${srPreset}`,

                myOwn: "https://photos.app.goo.gl/jYiWHQ56oTDUfAcJA",
            };
            let useImage;
            useImage = availableImages.srRedFlower;
            useImage = availableImages.srYellowFlower;
            useImage = availableImages.srFlowerAndBees;
            useImage = availableImages.myOwn;
            eltCanvas.style = `
                background-color: darkgoldenrod;
                outline: 2px dotted darkgoldenrod;
                width: 100%;
                aspect-ratio: 1 / 1;
                NObackground-image: url(https://static-cdn.sr.se/images/83/e295c2fb-fd0b-4b40-b22d-57ec63ab7b67.jpg?preset=1024x576&format=webp);
                NObackground-image: url("https://static-cdn.sr.se/images/83/5f3f6e55-5d96-489a-853b-e9f9e7702ec5.jpg?preset=1024x576&format=webp");
                NObackground-image: url(https://static-cdn.sr.se/images/83/ebffc0d1-3bf9-48ad-921f-9449fdc46fcf.jpg?preset=1024x576&format=webp);
                background-image: url(${useImage});
                background-size: cover;
                background-position: center;
            `;
            ctxCanvas = eltCanvas.getContext("2d");
        }
        let isRunning = false;
        async function setupControls(container) {
            const modMdc = await import("util-mdc");
            // const modMdc = await import("http://localhost:8080/public/src/js/mod/util-mdc.js");
            // const btnStart = mkElt("button", undefined, "Start");
            const iconStart = modMdc.mkMDCicon("play_arrow");
            const btnStart = modMdc.mkMDCiconButton(iconStart, "Start");
            // btnStart.classList.add("icon-button-30");
            btnStart.id = "start-button";
            btnStart.addEventListener("click", evt => {
                document.documentElement.classList.add("running");
                console.log({ currentPattern });
                isRunning = true;
                msStart = document.timeline.currentTime;
                numChecks = 0;
                numRedraw = 0;
                animateLines();
            });

            const iconReplay = modMdc.mkMDCicon("replay");
            const btnReset = modMdc.mkMDCiconButton(iconReplay, "Rewind");
            // btnReset.classList.add("icon-button-30");
            btnReset.addEventListener("click", evt => {
                initCurrentPattern();
            });
            btnReset.id = "replay-button";

            const divChangeTime = (() => {
                const iconLess = modMdc.mkMDCicon("expand_circle_down");
                const btnLess = modMdc.mkMDCiconButton(iconLess, "Shorter");

                // const iconMore = modMdc.mkMDCicon("expand_circle_up");
                // FIX-ME: For some reason the up version does not work??
                //    Using this workaround:
                const iconMore = modMdc.mkMDCicon("expand_circle_down");
                iconMore.style.transform = "rotate(180deg)";
                const btnMore = modMdc.mkMDCiconButton(iconMore, "Longer");

                const eltShow = mkElt("span", undefined, "time");
                eltShow.style = `
                    background-color: #0004;
                    padding: 4px;
                    width: 50px;
                    text-align: center;
                `;
                const div = mkElt("div", { class: "mdc-card", id: "set-time" }, [
                    btnLess, eltShow, btnMore
                ]);
                div.style = `
                    background-color: rgba(255, 255, 0, 0.2);
                    NOdisplay: inline-flex;
                    flex-direction: row;
                    gap: 5px;
                    align-items: center;
                `;
                return div;
            })();

            // const iconSettings = modMdc.mkMDCicon("settings");
            // const iconSettings = modMdc.mkMDCicon("settings_heart");
            const iconSettings = modMdc.mkMDCicon("video_settings");
            // const iconSettings = modMdc.mkMDCicon("spa");
            const btnSettings = modMdc.mkMDCiconButton(iconSettings, "Start");
            // btnSettings.classList.add("icon-button-30");
            btnSettings.addEventListener("click", async evt => {
                // dialogPattern();
                const bdy = mkElt("div", undefined, [
                    mkElt("h2", undefined, "Breath speed"),
                    "not implemented yet",
                ]);
                modMdc.mkMDCdialogConfirm(bdy);
            });
            btnSettings.id = "settings-button";

            // mkMDCfab(eltIcon, title, mini, extendTitle)
            const icoPattern = modMdc.mkMDCicon("spa");
            icoPattern.style.color = "greenyellow";
            const fabPattern = modMdc.mkMDCfab(icoPattern, "Choose breathing pattern", true);
            fabPattern.addEventListener("click", evt => {
                dialogPattern();
            });
            fabPattern.style.backgroundColor = "orange";
            fabPattern.style.backgroundColor = "#ffa500a1";
            const eltPatternInfo = mkElt("span", undefined, "Wait")
            eltPatternInfo.id = "elt-pattern-info";
            const divPattern = mkElt("p", undefined, [
                fabPattern,
                eltPatternInfo,
            ]);
            divPattern.style = `
                display: flex;
                gap: 10px;
            `;
            container.appendChild(divPattern);
            setTimeout(tellCurrentPattern, 100);

            const divInstructions = mkElt("p", undefined, "Wait ");
            divInstructions.id = "elt-instructions";
            container.appendChild(divInstructions);
            tellInitialState();

            const divControls = mkElt("div", undefined, [
                btnStart,
                btnReset,
                divChangeTime,
                btnSettings,
            ]);
            divControls.style = `
                display: flex;
                gap: 5px;
            `;
            container.appendChild(divControls);
        }
        function setupThings() {
            // const container = document.body;
            const container = mkElt("section");
            container.style = `
                max-height: 100%;
                max-width: 100%;
                max-width: calc(100% - 40px);
                aspect-ratio: 1.0 / 1.4;
                NObackground: gray;
                margin: 20px auto;
            `;
            document.body.appendChild(container);
            setupCanvas(container);
            setupControls(container);
        }

    </script>
    <style>
        body {
            background: black;
            color: orange;
        }


        .running #start-button {
            display: none;
        }

        .running #settings-button {
            display: none;
        }


        #set-time {
            display: inline-flex;
        }

        .running #set-time {
            display: none;
        }


        #replay-button {
            display: none;
        }

        .running #replay-button {
            display: unset;
        }


        div.mdc-dialog__surface:has(#test-dialog-pattern) {
            background-color: orange;
        }

        div.mdc-dialog__surface:has(#testdialog-pattern) {
            background-color: #333300;
            color: orange !important;
        }

        div.mdc-dialog__surface:has(.colored-dialog) {
            background-color: green;
            background-color: orange;
        }
    </style>
</head>

<body>
    <script>
        setupThings();

        function redraw() {
            let myPatt = breathPatterns[currentPattern];
            drawPattern(myPatt, 1.05);
        }
        // checkRedraw();
        function checkRedraw() {
            // const ms = Date.now() - msStart;
            const ms = document.timeline.currentTime - msStart;
            if (ms > 19 * 1000) {
                console.log("stopping time...");
                tellState("Finished");
                drawCurrentPoint("gray");
                isRunning = false;
                stopRedraw = true;
                return false;
            }
            if (numChecks > 100) {
                console.log("stopping num...");
                stopRedraw = true;
                return false;
            }
            redraw();
            return true;
        }

        let numRedraw = 0;
        setTimeout(() => {
            msStart = document.timeline.currentTime;
            redraw();
        }, 100);


        function animateLines() {
            if (!isRunning) return;
            const ok = checkRedraw();
            if (!ok) return;
            requestAnimationFrame(() => {
                if (numRedraw++ > 3000) {
                    console.log("stopping sec check", { numRedraw });
                    return;
                }
                animateLines();
            });
        }

    </script>

</body>