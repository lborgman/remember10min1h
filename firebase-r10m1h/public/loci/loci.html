<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- This page Â© Copyright 2023, Lennart Borgman -->
    <meta name="author" content="Lennart Borgman">
    <meta name="description" content="Memory palace, loci, for Internet">
    <link rel="manifest" href="manifest-loci.json">
    <meta name="theme-color" content="#c0ca33">

    <title>Memory Palace 4 Internet</title>
    <link rel="icon" type="image/svg+xml" href="/img/loci.svg">


    <!-- for MWC, https://github.com/material-components/material-web -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
    <link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Material+Icons&amp;display=block" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

    <!-- Required styles for Material Web -->
    <link rel="stylesheet" href="https://unpkg.com/material-components-web@latest/dist/material-components-web.css">
    <!-- <link rel="stylesheet" href="/ext/mdc/14.0.0/material-components-web.css"> -->

    <link rel="stylesheet" href="/css/rem10m1h.css">
    <link rel="stylesheet" href="/css/jsmind-edit.css">
    <link id="jsmind-my-colors" rel="stylesheet" href="/css/var-colors.css">


    <script src="/src/js/fc4i-importmaps.js"></script>


    <script src="/src/js/error.js"></script>
    <script src="/src/js/umd/idb.js"></script>
    <!-- <script src="./src/js/is-displayed.js"></script> -->


    <!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jsmind@0.5/style/jsmind.css" /> -->
    <link rel="stylesheet" href="/ext/jsmind/jsmind.css" />

    <!-- <script src="https://cdn.jsdelivr.net/npm/jsmind@0.5/es6/jsmind.js"></script> -->
    <!-- <script src="https://cdn.jsdelivr.net/npm/jsmind/es6/jsmind.js"></script> -->
    <!-- <script src="/ext/jsmind/jsmind-dbg.js"></script> -->

    <!-- <script src="https://cdn.jsdelivr.net/npm/jsmind@0.5/es6/jsmind.draggable-node.js"></script> -->
    <!-- <script src="/ext/jsmind/230406-jsmind.draggable-node.js"></script> -->

    <!-- <script src="/ext/jsmind/chrome-src-jsmind.draggable-node.js"></script> -->

    <!-- <script src="/src/js/mindmap-helpers.js"></script> -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pannellum@2.5.6/build/pannellum.css" />
    <!-- <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/pannellum@2.5.6/build/pannellum.js"></script> -->
    <script type="text/javascript" src="/ext/pannellum/libpannellum.js"></script>
    <script type="text/javascript" src="/ext/pannellum/pannellum.js"></script>
    <style>
        #pannellum-container {
            width: 300px;
            height: 200px;
        }
    </style>
</head>

<body class="NOno-test-items">

    <script src="https://unpkg.com/material-components-web@latest/dist/material-components-web.min.js"></script>

    <div id="panorama" class="panorama"></div>

    <script>
        // https://pannellum.org/
        let srcImg;
        let scaleImg;
        let blobImg;
        let srcBlobImg;
        let srcPanorama;
        function isBlobImage(src) { return typeof src == "object"; };
        async function addXmpdata(imgBlob, xmpData) {
            // https://www.npmjs.com/package/png-itxt - doesn't work any more
            // https://stackoverflow.com/questions/52549273/insert-png-comment-block-itxt-using-javascript
            // https://github.com/kujirahand/node-png-metadata/blob/master/src/lib/png-metadata.js
            // https://stackoverflow.com/questions/6965107/converting-between-strings-and-arraybuffers
            // https://medium.com/@naveenkumarasinghe/javascript-lost-in-binaries-buffer-blob-uint8array-arraybuffer-ed8d2b4de44a
            const modPngMeta = await import("/ext/png-meta/png-metadata.js");
            const imgArrBuff = await imgBlob.arrayBuffer();

            // const dec = new TextDecoder("utf-8");
            // const enc = new TextEncoder();
            // const imgStr = dec.decode(imgArrBuff);

            // https://stackoverflow.com/questions/50198017/converting-arraybuffer-to-string-then-back-to-arraybuffer-using-textdecoder-text
            // const imgStr = String.fromCharCode(...new Uint8Array(imgArrBuff));
            const arrU8 = new Uint8Array(imgArrBuff);
            const arrImgStr = [];
            for (let i = 0, len = arrU8.length; i < len; i++) {
                const charCode = arrU8[i];
                const char = String.fromCharCode(charCode);
                arrImgStr.push(char);
            }
            const imgStr1 = arrImgStr.join('');
            const imgStr = BinaryToString(imgStr1);


            const chunks = modPngMeta.metadata.splitChunk(imgStr);
            if (!chunks) { debugger; }
            const joinedChunks = modPngMeta.metadata.joinChunk(chunks);
            // const newBlob = new Blob([joinedChunks]);
            let newBlob = new Blob([joinedChunks], { type: "image/png" });
            return newBlob;


            function ArrayBufferToString(buffer) {
                return BinaryToString(
                    String.fromCharCode.apply(
                        null,
                        Array.prototype.slice.apply(new Uint8Array(buffer))));
            }

            function BinaryToString(binary) {
                var error;

                try {
                    return decodeURIComponent(escape(binary));
                } catch (_error) {
                    error = _error;
                    if (error instanceof URIError) {
                        return binary;
                    } else {
                        throw error;
                    }
                }
            }
        }
        async function mkImageBlob(srcImg, scale) {
            const tofSrcImg = typeof srcImg;
            if (tofSrcImg != "string") throw Error(`typeof srcImg=="${tofSrcImg}", should be "string")`);
            if (srcImg.slice(0, 4) == "blob") throw Error("srcImg is blob url");
            // https://stackoverflow.com/questions/42471755/convert-image-into-blob-using-javascript
            const img = new Image;
            const eltCanvas = document.createElement("canvas");
            const ctx = eltCanvas.getContext("2d");
            const imgData = await getImgData(srcImg);
            console.log("orig", { imgData });
            return new Promise(resolve => {
                img.onload = function () {
                    eltCanvas.width = imgData.naturalWidth * scale;     // update canvas size to match image
                    eltCanvas.height = imgData.naturalHeight * scale;
                    // ctx.drawImage(this, 0, 0);       // draw in image
                    // https://codesalad.dev/blog/how-to-resize-an-image-in-10-lines-of-javascript-29
                    ctx.drawImage(this, 0, 0, eltCanvas.width, eltCanvas.height);       // draw in image
                    eltCanvas.toBlob(function (blob) {        // get content as JPEG blob
                        // here the image is a blob
                        // blobImg = blob;
                        resolve(blob);
                    }, "image/png", 0.75);
                    // debugger;
                };
                img.crossOrigin = "";              // if from different origin
                img.src = srcImg;
            });
        }
        async function getImgData(strUrlImg) {
            return new Promise((resolve) => {
                const image = new Image();
                image.onload = async () => {
                    const naturalWidth = image.naturalWidth;
                    const naturalHeight = image.naturalHeight;
                    const width = image.width;
                    const height = image.height;
                    resolve({ naturalWidth, naturalHeight, width, height });
                }
                image.onerror = async () => {
                    console.log("ERROR");
                }
                image.src = strUrlImg;
            });
        }

        (async () => {
            const modMdc = await import("util-mdc");
            const immages = [
                "https://pannellum.org/images/alma.jpg",
                new URL("./testimg/PANO1.jpg", location),
            ];

            dialogPreparePanorama();
            async function dialogPreparePanorama() {
                const debounceUpdateBlobAndPreview = debounce(updateBlobAndPreview);

                const divImgs = mkElt("div");
                divImgs.style = `
                    display: flex;
                    gap: 10px;
                    flex-wrap: wrap;
                `;
                const divBlobPreview = mkElt("div");
                const divOrigPreview = mkElt("div");
                async function updateBlobAndPreview() {
                    // FIX-ME: Make this interruptable
                    blobImg = await mkImageBlob(srcImg, scaleImg);
                    // const blobAsText = await blobImg.text(); did not work
                    srcBlobImg = URL.createObjectURL(blobImg);

                    const newBlob = await addXmpdata(blobImg, "not ready");
                    srcBlobImg = URL.createObjectURL(newBlob);

                    const dataBlob = await getImgData(URL.createObjectURL(blobImg));
                    const dataOrig = await getImgData(srcImg);
                    divBlobPreview.textContent = `Blob w:${dataBlob.width} h:${dataBlob.height}`;
                    divOrigPreview.textContent = `Orig w:${dataOrig.width} h:${dataOrig.height}`;
                    divBlobPreview.style.backgroundImage = `url(${srcBlobImg})`;
                    divOrigPreview.style.backgroundImage = `url(${srcImg})`;
                }

                const canvas = mkElt("canvas");
                const webgl = canvas.getContext("webgl");
                const MAX_WEBGL_WIDTH = webgl.getParameter(webgl.MAX_TEXTURE_SIZE);
                const divMaxW = mkElt("div", undefined, `Max webgl width: ${MAX_WEBGL_WIDTH}`);

                const chkUseBlob = mkElt("input", { type: "checkbox" });
                const lblUseBlob = mkElt("label", undefined, ["Use blob:", chkUseBlob]);
                const inpScale = mkElt("input", { type: "number" });
                scaleImg = 0.5;
                inpScale.value = scaleImg;
                inpScale.addEventListener("input", evt => {
                    // FIX-ME: check value usable
                    let usableValue = false;
                    const strVal = inpScale.value.trim();
                    let val;
                    if (strVal.length > 0) {
                        val = parseFloat(strVal);
                        if (val > 0.2 && val < 2) usableValue = true;
                    }
                    if (!usableValue) {
                        inpScale.style.backgroundColor = "yellow";
                        return;
                    }
                    inpScale.style.backgroundColor = "unset";
                    scaleImg = val;
                    debounceUpdateBlobAndPreview();
                });
                const lblScale = mkElt("label", undefined, ["Scale:", inpScale]);
                const divInputs = mkElt("div", undefined, [lblUseBlob, lblScale]);
                divInputs.style = `
                    display: flex;
                    flex-direction: row;
                    gap: 10px;
                `;
                const pBlob = mkElt("p", undefined, [
                    mkElt("div", undefined, "Blob"),
                    divInputs,
                    divMaxW,
                    divBlobPreview,
                    divOrigPreview
                ])
                const body = mkElt("div", undefined, [
                    divImgs,
                    pBlob,
                ]);
                const previewStyle = `
                        background-size: contain;
                        background-repeat: no-repeat;
                        background-position: center;
                        aspect-ratio: 4 / 1;
                        outline: 1px dotted red;
                        color: red;
                        font-size: 20px;
                        text-shadow: 1px 0 black, -1px 0 black, 0 1px black, 0 -1px black, 0 0 2px black;
                `;
                divBlobPreview.style = previewStyle;
                divOrigPreview.style = previewStyle;
                immages.forEach(src => {
                    const eltImg = mkElt("div");
                    eltImg.style = `
                        background-image: url(${src});
                        background-size: contain;
                        background-repeat: no-repeat;
                        background-position: center;
                        width: 100px;
                        height: 50px;
                        outline: 1px dotted red;
                    `;
                    const eltRadio = mkElt("input", { type: "radio", name: "img", value: src });
                    const eltLbl = mkElt("label", undefined, [eltRadio, eltImg]);
                    divImgs.appendChild(eltLbl);
                    eltRadio.addEventListener("change", evt => {
                        srcImg = eltRadio.value;
                        debounceUpdateBlobAndPreview();
                    });

                });
                const btnShowPanorama = modMdc.mkMDCdialogButton("Test", "test");
                const eltActions = modMdc.mkMDCdialogActions([btnShowPanorama]);
                btnShowPanorama.addEventListener("click", errorHandlerAsyncEvent(async evt => {
                    evt.stopPropagation();
                    evt.stopImmediatePropagation();
                    evt.preventDefault();
                    const checked = divImgs.querySelector("input[type=radio]:checked");
                    console.log({ checked });
                    if (!checked) {
                        modMdc.mkMDCdialogAlert("Please choose an image");
                        return;
                    }
                    srcImg = checked.value;
                    srcPanorama = srcImg;
                    console.log({ srcImg, srcPanorama });
                    if (chkUseBlob.checked) {
                        // blobImg = await mkImageBlob(srcImg, inpScale.value);
                        srcPanorama = srcBlobImg;
                        // srcPanorama = isBlobImage(srcPanorama) ? URL.createObjectURL(srcPanorama) : srcPanorama;
                    }
                    closeDialog();
                    showPanorama(srcPanorama);
                }));

                const dlg = await modMdc.mkMDCdialog(body, eltActions);
                function closeDialog() { dlg.mdc.close(); }
            }

            async function showPanorama(srcPanorama) {
                const dataImg = await getImgData(srcPanorama);
                // const is360 = true;
                const devMaxWebGlW = 8192; // FIX-ME: This is from Pixel 7
                if (dataImg.naturalWidth > devMaxWebGlW) {
                    const modImg = await import("images");
                    // debugger;
                    // modImg.shrinkImageBlob();
                }
                const is360 = true;
                if (is360) {
                    const cont = document.getElementById("panorama");
                    cont.style.outline = "1px dotted red";
                    const viewer = pannellum.viewer(
                        // 'panorama',
                        cont,
                        {
                            "type": "equirectangular",
                            "panorama": srcPanorama,
                            "autoLoad": true,
                            "compass": true,
                        });
                    let mousedownData;
                    viewer.on("mousedown", (evt) => {
                        const coords = viewer.mouseEventToCoords(evt);
                        const pitch = coords[0], yaw = coords[1];
                        const cx = evt.clientX;
                        const cy = evt.clientY;
                        console.log("mousedown", { pitch, yaw, cx, cy, evt });
                        mousedownData = { pitch, yaw, cx, cy };
                    });
                    viewer.on("mouseup", (evt) => {
                        const coords = viewer.mouseEventToCoords(evt);
                        const pitch = coords[0], yaw = coords[1];
                        const cx = evt.clientX;
                        const cy = evt.clientY;
                        console.log("mouseup", { pitch, yaw, cx, cy });
                        if (mousedownData.cx == cx && mousedownData.cy == cy) {
                            viewer.addHotSpot({ pitch, yaw, type: "info", text: "infoText" });
                        }
                    });
                }
            }
        })();
    </script>
</body>

</html>