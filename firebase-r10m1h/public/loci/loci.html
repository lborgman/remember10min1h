<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- This page Â© Copyright 2023, Lennart Borgman -->
    <meta name="author" content="Lennart Borgman">
    <meta name="description" content="Memory palace, loci, for Internet">
    <!-- <link rel="manifest" href="manifest-loci.json"> -->
    <meta name="theme-color" content="#c0ca33">

    <title>Memory Palace 4 Internet</title>
    <link rel="icon" type="image/svg+xml" href="/img/loci.svg">


    <!-- for MWC, https://github.com/material-components/material-web -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
    <link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Material+Icons&amp;display=block" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

    <!-- Required styles for Material Web -->
    <link rel="stylesheet" href="https://unpkg.com/material-components-web@latest/dist/material-components-web.css">
    <!-- <link rel="stylesheet" href="/ext/mdc/14.0.0/material-components-web.css"> -->

    <link rel="stylesheet" href="/css/rem10m1h.css">
    <link rel="stylesheet" href="/css/jsmind-edit.css">
    <link id="jsmind-my-colors" rel="stylesheet" href="/css/var-colors.css">


    <script src="/src/js/fc4i-importmaps.js"></script>


    <script src="/src/js/error.js"></script>
    <script src="/src/js/umd/idb.js"></script>
    <!-- <script src="./src/js/is-displayed.js"></script> -->


    <!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jsmind@0.5/style/jsmind.css" /> -->
    <link rel="stylesheet" href="/ext/jsmind/jsmind.css" />

    <!-- <script src="https://cdn.jsdelivr.net/npm/jsmind@0.5/es6/jsmind.js"></script> -->
    <!-- <script src="https://cdn.jsdelivr.net/npm/jsmind/es6/jsmind.js"></script> -->
    <!-- <script src="/ext/jsmind/jsmind-dbg.js"></script> -->

    <!-- <script src="https://cdn.jsdelivr.net/npm/jsmind@0.5/es6/jsmind.draggable-node.js"></script> -->
    <!-- <script src="/ext/jsmind/230406-jsmind.draggable-node.js"></script> -->

    <!-- <script src="/ext/jsmind/chrome-src-jsmind.draggable-node.js"></script> -->

    <!-- <script src="/src/js/mindmap-helpers.js"></script> -->

    <!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pannellum@2.5.6/build/pannellum.css" /> -->
    <link rel="stylesheet" href="/ext/pannellum/pannellum.css" />
    <!-- <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/pannellum@2.5.6/build/pannellum.js"></script> -->
    <script type="text/javascript" src="/ext/pannellum/libpannellum.js"></script>
    <script type="text/javascript" src="/ext/pannellum/pannellum.js"></script>
    <style>
        .my-hotspot-div {
            padding: 10px;
            min-width: 100px;
            NOopacity: 0.5;
        }

        #pannellum-container {
            NOwidth: 300px;
            NOheight: 200px;
        }

        #panorama-container {
            NOdisplay: flex;
            NOjustify-content: center;
        }

        #panorama {
            aspect-ratio: 1 / 1;
            width: unset;
            height: unset;
            max-width: 97vw;
            max-height: 97vh;
            margin-left: auto;
            margin-right: auto;
            outline: 2px dashed red;
        }

        #palace-title {
            color: skyblue;
            display: flex;
            justify-content: center;
            line-height: 2rem;
        }

        body {
            background: black;
            padding: 0;
            margin: 0;
        }
    </style>
</head>

<body class="NOno-test-items">

    <script src="https://unpkg.com/material-components-web@latest/dist/material-components-web.min.js"></script>

    <div id="palace-title">Title here</div>
    <div id="panorama-container">
        <div id="panorama" class="panorama"></div>
    </div>

    <script>
        // https://pannellum.org/
        const devMaxWebGlW = 8192; // FIX-ME: This is from Pixel 7
        // const devMaxWebGlW = getDeviceMaxImageSize();
        let srcImgOrig;
        let xmpImg;
        let scaleImg;
        let blobImg;
        let srcBlobImg;
        let srcPanorama;

        function getDeviceMaxImageSize() {
            const canvas = mkElt("canvas");
            const gl = canvas.getContext('experimental-webgl', { alpha: false, depth: false });
            const devMaxWebGlW = gl.getParameter(gl.MAX_TEXTURE_SIZE);
            return devMaxWebGlW;
        }

        /*
        async function addXmpdata(imgBlob, xmpData)
            // https://www.npmjs.com/package/png-itxt - doesn't work any more
            // https://stackoverflow.com/questions/52549273/insert-png-comment-block-itxt-using-javascript
            // https://github.com/kujirahand/node-png-metadata/blob/master/src/lib/png-metadata.js
            // https://stackoverflow.com/questions/6965107/converting-between-strings-and-arraybuffers
            // https://medium.com/@naveenkumarasinghe/javascript-lost-in-binaries-buffer-blob-uint8array-arraybuffer-ed8d2b4de44a
        */
        async function mkScaledImageBlob(srcImg, scale) {
            const tofSrcImg = typeof srcImg;
            if (tofSrcImg != "string") throw Error(`typeof srcImg=="${tofSrcImg}", should be "string")`);
            if (srcImg.slice(0, 4) == "blob") throw Error("srcImg is blob url");
            // https://stackoverflow.com/questions/42471755/convert-image-into-blob-using-javascript
            const img = new Image;
            const eltCanvas = document.createElement("canvas");
            const ctx = eltCanvas.getContext("2d");
            const imgSizes = await getImgSizes(srcImg);
            console.log("orig", { imgSizes });
            return new Promise((resolve, reject) => {
                img.onload = function () {
                    // if (typeof imgSizes != "undefined") {
                    eltCanvas.width = imgSizes.naturalWidth * scale;     // update canvas size to match image
                    eltCanvas.height = imgSizes.naturalHeight * scale;
                    // }
                    // https://codesalad.dev/blog/how-to-resize-an-image-in-10-lines-of-javascript-29
                    ctx.drawImage(this, 0, 0, eltCanvas.width, eltCanvas.height);       // draw in image
                    eltCanvas.toBlob(blob => {        // get content as JPEG blob
                        // here the image is a blob
                        // blobImg = blob;
                        resolve(blob);
                    },
                        // "image/png"
                        "image/webp", 0.75
                        // "image/jpeg", 0.75
                    );
                    // debugger;
                };
                img.onerror = function () {
                    debugger;
                    resolve(false);
                }
                img.crossOrigin = "";              // if from different origin
                img.src = srcImg;
            });
        }
        async function getImgSizes(strUrlImg) {
            return new Promise((resolve) => {
                const image = new Image();
                image.onload = async () => {
                    const naturalWidth = image.naturalWidth;
                    const naturalHeight = image.naturalHeight;
                    const width = image.width;
                    const height = image.height;
                    resolve({ naturalWidth, naturalHeight, width, height });
                }
                // image.onerror = async () => { console.log("ERROR"); }
                image.addEventListener("error", evt => {
                    console.log("ERROR", { evt, strUrlImg });
                    debugger;
                    resolve(false);
                })
                image.src = strUrlImg;
            });
        }

        (async () => {
            const modMdc = await import("util-mdc");
            const immages = [
                "https://pannellum.org/images/alma.jpg",
                new URL("./testimg/PANO1.jpg", location),
                new URL("./testimg/PHOTOSPHERE1.jpg", location),
                new URL("./testimg/Botan-SPHERE1.jpg", location),
            ];

            dialogChooseImage4Panorama();
            async function dialogChooseSubjectForImage(srcType, srcOrigName, srcRoomImg) {
                const divPreview = mkElt("div");
                divPreview.style = `
                        background-image: url(${srcRoomImg});
                        background-size: contain;
                        background-repeat: no-repeat;
                        height: 100%;
                        ratio: 1 / 2;
                `;

                const idImg = mkIdImg(srcType, srcOrigName);
                const arrHotspotGrps = getAllHotspotGrps(idImg);
                const divExistingGrps = mkElt("div");
                divExistingGrps.style = `
                    display: flex;
                    flex-direction: column;
                    gap: 10px;
                    `;
                const divGrps = mkElt("div", undefined, divExistingGrps);
                const divBtnDelGrps = mkElt("div");
                if (arrHotspotGrps.length > 0) {
                    arrHotspotGrps.forEach(item => {
                        // const item = JSON.parse(localStorage.getItem(k));
                        const id = item.id;
                        if (item.id) {
                            const rad = mkElt("input", { type: "radio", name: "mem", value: id });
                            rad.dataset.subject = item.subject;
                            const lbl = mkElt("label", undefined, [rad, item.subject]);
                            divExistingGrps.appendChild(lbl);
                        }
                    });
                    const btnDelGrps = modMdc.mkMDCbutton("delete groups");
                    btnDelGrps.addEventListener("click", evt => {
                        const arrKeys = getAllHotspotGrpKeys(idImg);
                        arrKeys.forEach(k => localStorage.removeItem(k));
                        divExistingGrps.textContent = "All groups have been deleted";
                    });
                    divBtnDelGrps.appendChild(btnDelGrps);
                } else {
                    divExistingGrps.textContent = "There are no saved subjects for this image.";
                }
                const radNew = mkElt("input", { type: "radio", name: "mem", value: "FROM_INPUT" });
                const inpNew = mkElt("input", { type: "text" });
                const lblNew = mkElt("label", undefined, [radNew, "New: ", inpNew]);
                divExistingGrps.appendChild(lblNew);
                const rad1 = divExistingGrps.querySelector("input[type=radio]");
                rad1.checked = true;

                const body = mkElt("div", undefined, [
                    mkElt("h2", undefined, "Choose subject"),
                    divPreview,
                    // divExistingGrps,
                    divGrps,
                    divBtnDelGrps,
                ]);
                // return await modMdc.mkMDCdialogConfirm(body);
                // return await modMdc.mkMDCdialogConfirm(body);
                const btnCancel = modMdc.mkMDCdialogButton("Cancel", "close");
                const btnConfirmSubject = modMdc.mkMDCdialogButton("Continue", "continue", true);
                let subject4image;
                let idGrp4image;
                btnConfirmSubject.addEventListener("click", errorHandlerAsyncEvent(async evt => {
                    const checked = divExistingGrps.querySelector("input[type=radio]:checked");
                    if (checked == radNew) {
                        subject4image = inpNew.value.trim();
                        if (subject4image.length == 0) {
                            evt.stopPropagation();
                            evt.stopImmediatePropagation();
                            evt.preventDefault();
                            inpNew.focus();
                            modMdc.mkMDCdialogAlert("Please input a name for the new subject!");
                            return;
                        }
                        // idGrp4image = checked.value;
                        // const memKeyPrefix = mkHotspotKeyPrefix(idImg);
                        // objHotspotGrp4panorama.idGrp = new Date().toISOString();
                        idGrp4image = new Date().toISOString();
                    } else {
                        idGrp4image = checked.value;
                        subject4image = checked.dataset.subject;
                    }
                    console.log({ checked, subject4image, inpNew });
                    // closeDialog();
                }));
                const eltActions = modMdc.mkMDCdialogActions([btnConfirmSubject, btnCancel]);
                const dlg = await modMdc.mkMDCdialog(body, eltActions);
                function closeDialog() { dlg.mdc.close(); }
                return await new Promise((resolve, reject) => {
                    dlg.dom.addEventListener("MDCDialog:closed", errorHandlerAsyncEvent(async evt => {
                        const action = evt.detail.action;
                        switch (action) {
                            case "continue":
                                const rec = {
                                    subjectGrp: subject4image, // FIX-ME: subject vs id
                                    idGrp: idGrp4image,
                                    idImg
                                }
                                resolve(rec);
                                break;
                            case "close":
                                resolve(false);
                                break;
                            default:
                                throw Error(`error in mkMDCdialogConfirm, action is ${action}`)
                        }
                    }));
                });
            }
            async function dialogChooseImage4Panorama() {
                const debounceUpdateBlobAndPreview = debounce(updateBlobAndPreview);

                const divImgs = mkElt("div");
                divImgs.style = `
                    display: flex;
                    gap: 10px;
                    flex-wrap: wrap;
                `;
                const divBlobPreview = mkElt("div");
                const divOrigPreview = mkElt("div");

                async function updateBlobAndPreview() {
                    // FIX-ME: Make this interruptable
                    if (srcImgOrig == undefined) return;

                    divOrigPreview.style.backgroundImage = `url(${srcImgOrig})`;
                    blobImg = await mkScaledImageBlob(srcImgOrig, scaleImg);
                    // const blobAsText = await blobImg.text(); did not work
                    srcBlobImg = URL.createObjectURL(blobImg);
                    divBlobPreview.style.backgroundImage = `url(${srcBlobImg})`;

                    // const newBlob = await addXmpdata(blobImg, "not ready");
                    // srcBlobImg = URL.createObjectURL(newBlob);

                    const sizesOrig = await getImgSizes(srcImgOrig);
                    divOrigPreview.textContent = `Orig w:${sizesOrig.width} h:${sizesOrig.height}`;

                    const sizesBlob = await getImgSizes(srcBlobImg);
                    divBlobPreview.textContent = `Blob w:${sizesBlob.width} h:${sizesBlob.height} s:${blobImg.size}`;

                    const origBlob = await new Promise(resolve => {
                        fetch(srcImgOrig)
                            .then(response => response.blob())
                            .then(blob => resolve(blob));
                    });
                    xmpImg = await pannellum.parseGPanoXMP(origBlob);
                    divXmpInfo.textContent = JSON.stringify(xmpImg, undefined, 4);


                    if (sizesOrig.width > devMaxWebGlW) {
                        chkUseBlob.checked = true;
                        chkUseBlob.disabled = true;
                    } else {
                        chkUseBlob.checked = false;
                        chkUseBlob.disabled = false;
                    }
                }

                const canvas = mkElt("canvas");
                const webgl = canvas.getContext("webgl");
                const MAX_WEBGL_WIDTH = webgl.getParameter(webgl.MAX_TEXTURE_SIZE);
                const divMaxW = mkElt("div", undefined, `Max webgl width: ${MAX_WEBGL_WIDTH}`);

                const chkUseBlob = mkElt("input", { type: "checkbox" });
                const lblUseBlob = mkElt("label", undefined, ["Use blob:", chkUseBlob]);
                const inpScale = mkElt("input", { type: "number" });
                scaleImg = 0.2;
                inpScale.value = scaleImg;
                inpScale.addEventListener("input", evt => {
                    // FIX-ME: check value usable
                    let usableValue = false;
                    const strVal = inpScale.value.trim();
                    let val;
                    if (strVal.length > 0) {
                        val = parseFloat(strVal);
                        if (val > 0.02 && val < 2) usableValue = true;
                    }
                    if (!usableValue) {
                        inpScale.style.backgroundColor = "yellow";
                        return;
                    }
                    inpScale.style.backgroundColor = "unset";
                    scaleImg = val;
                    debounceUpdateBlobAndPreview();
                });
                const lblScale = mkElt("label", undefined, ["Scale:", inpScale]);
                const divInputs = mkElt("div", undefined, [lblUseBlob, lblScale]);
                divInputs.style = `
                    display: flex;
                    flex-direction: row;
                    gap: 10px;
                `;
                const divXmpInfo = mkElt("pre");
                const pBlob = mkElt("p", undefined, [
                    mkElt("div", undefined, "Blob"),
                    divInputs,
                    divMaxW,
                    divOrigPreview,
                    divBlobPreview,
                    divXmpInfo,
                ])
                const body = mkElt("div", undefined, [
                    mkElt("h2", undefined, "Choose image"),
                    divImgs,
                    pBlob,
                ]);
                const previewStyle = `
                        background-size: contain;
                        background-repeat: no-repeat;
                        background-position: center;
                        aspect-ratio: 4 / 1;
                        outline: 1px dotted red;
                        color: red;
                        font-size: 20px;
                        text-shadow: 1px 0 black, -1px 0 black, 0 1px black, 0 -1px black, 0 0 2px black;
                `;
                divOrigPreview.style = previewStyle;
                divBlobPreview.style = previewStyle;

                immages.forEach(src => {
                    const eltImg = mkElt("div");
                    eltImg.style = `
                        background-image: url(${src});
                        background-size: contain;
                        background-repeat: no-repeat;
                        background-position: center;
                        width: 100px;
                        height: 50px;
                        outline: 1px dotted red;
                    `;
                    const eltRadio = mkElt("input", { type: "radio", name: "img", value: src });
                    const eltLbl = mkElt("label", undefined, [eltRadio, eltImg]);
                    divImgs.appendChild(eltLbl);
                    eltRadio.addEventListener("change", evt => {
                        srcImgOrig = eltRadio.value;
                        debounceUpdateBlobAndPreview();
                    });

                });
                const firstImageRadio = divImgs.querySelector("input[name=img]");
                firstImageRadio.checked = true;
                const btnConfirmImage = modMdc.mkMDCdialogButton("Continue", "Choose image");
                const eltActions = modMdc.mkMDCdialogActions([btnConfirmImage]);
                btnConfirmImage.addEventListener("click", errorHandlerAsyncEvent(async evt => {
                    evt.stopPropagation();
                    evt.stopImmediatePropagation();
                    evt.preventDefault();
                    const checked = divImgs.querySelector("input[type=radio]:checked");
                    console.log({ checked });
                    if (!checked) {
                        modMdc.mkMDCdialogAlert("Please choose an image");
                        return;
                    }
                    srcImgOrig = checked.value;
                    srcPanorama = srcImgOrig;
                    console.log({ srcImgOrig, srcPanorama });
                    if (chkUseBlob.checked) {
                        srcPanorama = srcBlobImg;
                    }
                    const objHotspotsGrp = await dialogChooseSubjectForImage("app", srcImgOrig, srcPanorama);
                    if (!objHotspotsGrp) return;
                    closeDialog();
                    showPanorama(srcPanorama, xmpImg, objHotspotsGrp);
                }));

                const dlg = await modMdc.mkMDCdialog(body, eltActions);
                function closeDialog() { dlg.mdc.close(); }
            }

            async function showPanorama(srcPanorama, xmp, objHotspotGrp4panorama) {
                const eltTitle = document.getElementById("palace-title");
                eltTitle.textContent = objHotspotGrp4panorama.subjGrp;
                const sizesImg = await getImgSizes(srcPanorama);
                if (sizesImg.naturalWidth > devMaxWebGlW) {
                    debugger;
                }
                const hotspotGrpKey = mkHotspotGrpKey(objHotspotGrp4panorama.idImg, objHotspotGrp4panorama.idGrp);
                const cont = document.getElementById("panorama");
                cont.dataset.hotspotGrpKey = hotspotGrpKey;
                cont.style.outline = "1px dotted red";

                config =
                {
                    type: "equirectangular",
                    panorama: srcPanorama,
                    autoLoad: true,
                    compass: true,
                    avoidShowingBackground: true,
                    xmp,
                    createTooltipFunc: MYcreateTooltipFunc,
                    hotspotGrpKey,
                };

                const strOldRec = localStorage.getItem(hotspotGrpKey);
                let recHotspotGrp = strOldRec ? JSON.parse(strOldRec) : undefined;
                if (recHotspotGrp) {
                    const arrHotspots = recHotspotGrp.hotspots;
                    if (arrHotspots.length > 0) { config.hotSpots = arrHotspots; }
                }

                const viewer = pannellum.viewer(cont, config);
                let mousedownData;
                viewer.on("mousedown", (evt) => {
                    const coords = viewer.mouseEventToCoords(evt);
                    const pitch = coords[0], yaw = coords[1];
                    const cx = evt.clientX;
                    const cy = evt.clientY;
                    console.log("mousedown", { pitch, yaw, cx, cy, evt });
                    mousedownData = { pitch, yaw, cx, cy };
                });
                viewer.on("mouseup", (evt) => {
                    const coords = viewer.mouseEventToCoords(evt);
                    const pitch = coords[0], yaw = coords[1];
                    const cx = evt.clientX;
                    const cy = evt.clientY;
                    console.log("mouseup", { pitch, yaw, cx, cy });
                    if (mousedownData.cx == cx && mousedownData.cy == cy) {
                        const hs = {
                            pitch, yaw,
                            type: "info",
                            text: "infoText",
                        };
                        addHotSpotToPanorama(hs);
                    }
                });

                function addHotSpotToPanorama(data) {
                    // data.createTooltipFunc = MYcreateTooltipFunc;
                    data.id = Date.now();
                    viewer.addHotSpot(data);
                    const recHotspot = {
                        pitch: data.pitch,
                        yaw: data.yaw,
                        type: data.type,
                        text: data.text,
                        id: data.id,
                    }
                    const oldGrp = !!objHotspotGrp4panorama.idGrp;
                    // dataset
                    if (!oldGrp) {
                        // debugger;
                        throw Error("hotspot .idGrp is undefined");
                        // objHotspotGrp4panorama.idGrp = new Date().toISOString();
                    }
                    const hotspotGrpKey = mkHotspotGrpKey(objHotspotGrp4panorama.idImg, objHotspotGrp4panorama.idGrp);
                    const strOldRec = oldGrp ? localStorage.getItem(hotspotGrpKey) : undefined;
                    const oldRec = strOldRec ? JSON.parse(strOldRec) : undefined;
                    console.log({ data, objHotspotGrp4panorama, hotspotGrpKey, strOldRec, oldRec, recHotspot });
                    const rec = oldRec ||
                    {
                        subject: objHotspotGrp4panorama.subjectGrp,
                        id: objHotspotGrp4panorama.idGrp,
                        hotspots: []
                    }
                    rec.hotspots.push(recHotspot);
                    localStorage.setItem(hotspotGrpKey, JSON.stringify(rec));

                    const divHs = data.div;
                    addHilightHotspot(divHs);
                    setTimeout(errorHandlerAsyncEvent(async () => {
                        const divValues = divHs.lastElementChild.lastElementChild;
                        await editHotspot(divValues, recHotspot, hotspotGrpKey);
                        setTimeout(() => { removeHilightHotspot(divHs); }, 2000);
                    }), 1000);
                }


            }
        })();

        function mkIdImg(srcType, srcOrigNm) {
            const u = new URL(srcOrigNm);
            const pn = u.pathname;
            const lIdx = pn.lastIndexOf("/");
            const fn = pn.slice(lIdx + 1);
            return `${srcType}-${fn}`;
        }
        function mkHotspotKeyPrefix(idImg) { return `mem-${idImg}-`; }
        function mkHotspotGrpKey(idImg, idGrp) {
            if (idGrp == undefined) debugger;
            return `mem-${idImg}-${idGrp}`;
        }

        function getAllHotspotGrpKeys(idImg) {
            const memKeyPrefix = mkHotspotKeyPrefix(idImg);
            const allKeys = Object.keys(localStorage);
            const arrMemKeys = allKeys.filter(k => k.startsWith(memKeyPrefix));
            return arrMemKeys;
        }

        function getAllHotspotGrps(idImg) {
            const arrKeys = getAllHotspotGrpKeys(idImg);
            return arrKeys.map(k => {
                const str = localStorage.getItem(k);
                const json = JSON.parse(str);
                return json;
            });

        }

        function addHilightHotspot(divHs) {
            divHs.style.backgroundColor = "red";
            divHs.style.outline = "2px solid yellow";
        }
        function removeHilightHotspot(divHs) {
            divHs.style.backgroundColor = null;
            divHs.style.outline = null;
        }

        async function editHotspot(divValues, hs) {
            const tn = divValues.tagName;
            if (tn != "DIV") throw Error(`Expeced DIV, got ${tn}`);
            if (!divValues.parentElement) throw Error("divValues.parentElement is null");
            const modMdc = await import("util-mdc");
            const divPanorama = document.getElementById("panorama");
            const hotspotGrpKey = divPanorama.dataset.hotspotGrpKey
            const json = JSON.parse(localStorage.getItem(hotspotGrpKey));
            const hotspots = json.hotspots;
            const hotspot = (hotspots.filter(h => h.id == hs.id))[0];
            const taDesc = modMdc.mkMDCtextFieldTextarea(undefined, 3, 30);
            const tafDesc = modMdc.mkMDCtextareaField("Description", taDesc, hotspot.text);

            const inpURL = modMdc.mkMDCtextFieldInput(undefined, "url");
            inpURL.classList.add("remember-url");
            const reportInpURLvalidity = () => inpURL.reportValidity();
            const debounceReportInpURLvalidity = debounce(reportInpURLvalidity, 700);
            inpURL.addEventListener("input", evt => {
                const valid = inpURL.checkValidity();
                if (!valid) {
                    evt.stopImmediatePropagation();
                    setSaveButtonState(false);
                    debounceReportInpURLvalidity();
                }
            });
            const strUrl = hs.url ? hs.url : "";
            const tfURL = modMdc.mkMDCtextField("Link", inpURL, strUrl);

            const divInputs = mkElt("div", undefined, [
                tafDesc,
                tfURL,
            ]);
            divInputs.style = `
                display: flex;
                flex-direction: column;
                gap: 10px;
            `;

            const debounceInputHandling = debounce(checkCanSave, 500);
            divInputs.addEventListener("input", evt => {
                evt.stopPropagation();
                debounceInputHandling();
            });

            let saveButton;
            let savedValues;
            function checkCanSave() {
                const strCurrent = JSON.stringify(getCurrentValues());
                const strSaved = JSON.stringify(savedValues);
                const canSave = (strCurrent != strSaved)
                    && (inpURL.value.trim() == "" || inpURL.checkValidity());
                console.log("checkCanSave", canSave);
                if (!canSave) {
                    setSaveButtonState(false);
                } else {
                    setSaveButtonState(true);
                }
            }

            const title = hs.id ? "Edit hotspot" : "Create hotspot";
            const body = mkElt("div", undefined, [
                mkElt("h2", undefined, title),
                divInputs
            ]);

            function getCurrentValues() {
                const val = {};
                val.desc = taDesc.value;
                val.url = inpURL.value;
                return val;
            }

            function setSaveButtonState(canSave) {
                if (canSave) {
                    // FIX-ME: btnSave
                    saveButton.disabled = false;
                    saveButton.style.opacity = null;
                    // container.classList.add("not-saved");
                    // this.restartSaveNowTimer();
                } else {
                    saveButton.disabled = true;
                    saveButton.style.opacity = 0.5;
                    // No container yet if not on screen
                    // container?.classList.remove("not-saved");
                }
            }

            const handleResult = () => {
                const isUpdate =
                    (taDesc.value.trim() != hotspot.text)
                    ||
                    (inpURL.value.trim() != hotspot.url);
                if (isUpdate) {
                    hotspot.text = taDesc.value.trim();
                    hotspot.url = inpURL.value.trim();
                    return "update";
                }
            };

            function tellMeSaveButton(btn) {
                // debugger;
                saveButton = btn;
                setSaveButtonState(false);
                savedValues = getCurrentValues();
            }
            const ans = await modMdc.mkMDCdialogConfirm(
                body, "save", undefined, undefined, handleResult, tellMeSaveButton);
            if (ans == "update") {
                const saveJson = JSON.parse(localStorage.getItem(hotspotGrpKey));
                const oldHotspots = saveJson.hotspots;
                const saveHotspots = oldHotspots.filter(h => h.id != hs.id);
                saveHotspots.push(hotspot);
                saveJson.hotspots = saveHotspots;
                localStorage.setItem(hotspotGrpKey, JSON.stringify(saveJson));
                const divParent = divValues.parentElement;
                divValues.remove();
                const newDivValues = mkDivHotspotValues(hotspot);
                divParent.appendChild(newDivValues);
            }
        }

        function mkDivHotspotValues(hs) {
            const innerDesc = hs.url ? mkElt("a", { href: hs.url }) : mkElt("span");
            if (hs.text.length == 0) {
                innerDesc.textContent = "(No description)";
                innerDesc.style.color = "rgba(255, 0, 0, 0.5)";
                innerDesc.style.fontStyle = "italic";
            } else {
                innerDesc.textContent = hs.text;
            }
            const divDesc = mkElt("div", undefined, innerDesc);
            divDesc.style.fontSize = "1.2rem";
            divDesc.style.fontWeight = "bold";
            return divDesc;
        }

        async function MYcreateTooltipFunc(div, hs, hotspotGrpKey) {
            div.dataset.hotspotId = hs.id;
            // div.dataset.hotspotGrpKey = config.hotspotGrpKey;
            // origCreateTooltipFunc();
            const modMdc = await import("util-mdc");

            const btnClose = modMdc.mkMDCiconButton("close", "Close");
            btnClose.classList.add("icon-button-30");
            btnClose.style.background = "rgba(255, 0, 0, 0.2)";
            btnClose.style.position = "absolute";
            btnClose.style.top = "-7px";
            btnClose.style.left = "-7px";

            const divValues = mkDivHotspotValues(hs);

            const btnEdit = modMdc.mkMDCiconButton("edit", "Edit");
            btnEdit.classList.add("icon-button-30");
            btnEdit.style.background = "rgba(255, 0, 0, 0.2)";
            btnEdit.style.position = "absolute";
            btnEdit.style.top = "-7px";
            btnEdit.style.left = "50px";
            btnEdit.addEventListener("click", evt => {
                // editHotspot(divValues, hs, hotspotGrpKey);
                const divValues = myDiv.lastElementChild;
                editHotspot(divValues, hs, hotspotGrpKey);
            });

            const myDiv = mkElt("div", undefined, [
                btnClose,
                btnEdit,
                // mkElt("div", undefined, "my test5 div"),
                divValues,
            ]);
            myDiv.style.paddingTop = "37px";
            myDiv.classList.add("my-hotspot-div");
            myDiv.classList.add("mdc-card");
            myDiv.classList.add("display-none");

            btnClose.addEventListener("click", evt => {
                evt.stopPropagation();
                addHilightHotspot(div);
                setTimeout(() => {
                    myDiv.classList.add("display-none");
                }, 400);
                setTimeout(() => removeHilightHotspot(div), 1200);
            });


            div.appendChild(myDiv);
            div.addEventListener("click", evt => {
                addHilightHotspot(div);
                setTimeout(() => myDiv.classList.remove("display-none"), 700);
            });
            function origCreateTooltipFunc() {
                const span = mkElt("span", undefined, "HS: " + hs.text);
                // if (hs.text || hs.video || hs.image) {
                div.classList.add('pnlm-tooltip');
                div.appendChild(span);
                span.style.width = span.scrollWidth - 20 + 'px';
                span.style.marginLeft = -(span.scrollWidth - div.offsetWidth) / 2 + 'px';
                span.style.marginTop = -span.scrollHeight - 12 + 'px';
                // }
            }
        }



    </script>
</body>

</html>