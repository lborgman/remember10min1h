<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- for MWC, https://github.com/material-components/material-web -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
    <link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Material+Icons&amp;display=block" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

    <!-- Required styles for Material Web -->
    <link rel="stylesheet" href="https://unpkg.com/material-components-web@latest/dist/material-components-web.css">
    <!-- <link rel="stylesheet" href="/ext/mdc/14.0.0/material-components-web.css"> -->

    <link rel="stylesheet" href="css/rem10m1h.css">
    <link id="jsmind-my-colors" rel="stylesheet" href="css/var-colors.css">

    <script src="src/js/error.js"></script>
    <script src="src/js/umd/idb.js"></script>
    <script src="src/js/database.js"></script>


    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jsmind@0.5/style/jsmind.css" />
    <script src="https://cdn.jsdelivr.net/npm/jsmind@0.5/es6/jsmind.js"></script>
    <!-- <script src="https://cdn.jsdelivr.net/npm/jsmind@0.5/es6/jsmind.draggable-node.js"></script> -->
    <!-- <script src="/ext/jsmind/230406-jsmind.draggable-node.js"></script> -->

    <!-- <script src="/ext/jsmind/chrome-src-jsmind.draggable-node.js"></script> -->

    <script src="/src/js/mindmap-helpers.js"></script>
</head>

<body>
    <script src="/ext/mdc/material-components-web.js"></script>
    <div id="jsmind_container"></div>

    <script type="text/javascript">
        jsMind.my_get_DOM_element_from_node = (node) => { return node._data.view.element; }
        async function startDraggable() {
            const modJsmindDraggable = await import("/ext/jsmind/chrome-src-jsmind.draggable-node.js");
            console.log({ modJsmindDraggable });
        }
        errorHandlerAsyncEvent(startDraggable());
        function addDragDropTouch() {
            // if (!confirm("Load DragDropTouch.js?")) return;
            const elt = mkElt("script", { src: "/ext/DragDropTouch.js" });
            document.body.appendChild(elt);
        }
        if (hasTouchEvents()) {
            addDragDropTouch();
            // } else { addDragDropTouch();
        }

        // https://github.com/hizzgdev/jsmind
        function lookForCanvas() {
            // Just a bug workaround for jsmind
            // https://github.com/hizzgdev/jsmind/issues/432
            const canv = document.querySelector("canvas");
            if (canv) {
                console.log({ canv });
                canv.remove();
            }

        }
        // const lsMindKey = "test-mind";


        start();
        async function start() {
            const jsMindContainer = document.getElementById("jsmind_container");

            const btnDebugLogClear = mkElt("button", undefined, "Clear");
            btnDebugLogClear.addEventListener("click", evt => {
                divDebugLogLog.textContent = "";
            });
            const divDebugLogHeader = mkElt("div", { id: "jsmind-test-debug-header" }, [
                "JSMIND DEBUG LOG",
                btnDebugLogClear
            ]);
            const divDebugLogLog = mkElt("div", { id: "jsmind-test-div-debug-log-log" });
            const divDebugLog = mkElt("div", { id: "jsmind-test-div-debug-log" }, [
                divDebugLogHeader,
                divDebugLogLog
            ]);
            function addDebugLog(msg) {
                const prevRow = divDebugLogLog.lastElementChild;
                const prevMsg = prevRow?.firstElementChild.textContent;
                if (msg === prevMsg) {
                    const eltCounter = prevRow.lastElementChild;
                    const txtCounter = eltCounter.textContent.trim();
                    let counter = txtCounter === "" ? 1 : parseInt(txtCounter);
                    eltCounter.textContent = ++counter;
                } else {
                    const entry = mkElt("span", { class: "debug-entry" }, msg);
                    const counter = mkElt("span", { class: "debug-counter" }, " ");
                    const row = mkElt("div", { class: "debug-row" }, [entry, counter])
                    divDebugLogLog.appendChild(row);
                }
            }
            // jsMindContainer.appendChild(divDebugLog);
            let btnJsmindDebug;
            const idBtnJsmindDebug = "jsmind-ednode-debug-button";

            let btnJsmindMenu;
            const idBtnJsmindMenu = "jsmind-test-menu-button";
            let btnJsmindSearch;
            const idBtnJsmindSearch = "jsmind-search-button";
            let divSearchInputs;
            const idSearchInputs = "jsmind-search-inputs";
            addJsmindButtons();
            async function addJsmindButtons() {
                const modMdc = await import("/src/js/mod/util-mdc.js");

                btnJsmindDebug = modMdc.mkMDCiconButton("adb", "Debug log", 40);
                btnJsmindDebug.id = idBtnJsmindDebug;
                btnJsmindDebug.classList.add("jsmind-actions");
                jsMindContainer.appendChild(btnJsmindDebug);
                btnJsmindDebug.addEventListener("click", evt => {
                    console.log("btnJsmindMenu");
                    evt.stopPropagation();
                    jsMindContainer.classList.toggle("show-jsmind-debug");
                });


                btnJsmindMenu = modMdc.mkMDCiconButton("menu", "Open menu", 40);
                btnJsmindMenu.id = idBtnJsmindMenu;
                btnJsmindMenu.classList.add("jsmind-actions");
                jsMindContainer.appendChild(btnJsmindMenu);
                btnJsmindMenu.addEventListener("click", evt => {
                    // console.log("btnJsmindMenu");
                    evt.stopPropagation();
                    displayContextMenu(btnJsmindMenu, 10, 48);
                });
                btnJsmindSearch = modMdc.mkMDCiconButton("search", "Search", 40);
                btnJsmindSearch.id = idBtnJsmindSearch;
                btnJsmindSearch.classList.add("jsmind-actions");
                jsMindContainer.appendChild(btnJsmindSearch);
                btnJsmindSearch.addEventListener("click", evt => {
                    // console.log("btnJsmindSearch");
                    evt.stopPropagation();
                    toggleSearchInputs();
                });

                inpSearch = mkElt("input", { type: "search" });
                inpSearch.addEventListener("input", evt => {
                    restartJsmindSearch();
                })
                divSearchInputs = mkElt("div", { id: idSearchInputs }, inpSearch);
                divSearchInputs.classList.add("jsmind-actions");
                jsMindContainer.appendChild(divSearchInputs);
            }
            function displaySearchInputs() { jsMindContainer.classList.add("display-jsmind-search"); }
            function hideSearchInputs() { jsMindContainer.classList.remove("display-jsmind-search"); }
            function toggleSearchInputs() { jsMindContainer.classList.toggle("display-jsmind-search"); }
            let inpSearch;
            const restartJsmindSearch = (() => {
                let tmr;
                return () => {
                    clearTimeout(tmr);
                    tmr = setTimeout(() => doJsmindSearch(), 1000);
                }
            })();
            function doJsmindSearch() {
                const strSearch = inpSearch.value;
                jsmindSearchNodes(strSearch);
            }

            // https://github.com/hizzgdev/jsmind/blob/master/docs/en/1.usage.md#12-data-format
            const mindmapKey = new URLSearchParams(location.search).get("mindmap");
            if (typeof mindmapKey === "string" && mindmapKey.length === 0) {
                throw Error("Parameter mindmapname should have a value (key/name of a mindmap)");
            }
            const createMindmap = new URLSearchParams(location.search).get("createmindmap");
            if (typeof createMindmap === "string" && createMindmap.length > 0) {
                throw Error("Parameter createmindmap does not take a value");
            }
            const create = ((createMindmap != null) || (mindmapKey == null));
            console.log({ mindmapKey, createMindmap, create });
            let mind;
            if (create) {
                const keyFc4i = getJsmindCopied4Mindmap();
                if (keyFc4i) {
                    alert(`not ready: ${keyFc4i}`);
                    // return;
                    // getEmptyMap()
                    const nextKey = await getNextMindmapKey();
                    mind = getEmptyMap(nextKey);
                    // fc4i:
                    debugger;
                } else {
                    mind = await dialogCreateMindMap();
                }
            } else {
                // mind = getTestMindmap(mindmapName);
                mind = DBgetMindmap(mindmapKey);
            }
            // debugger;
            if (!mind) {
                return;
                // let formatEmpty = "node_array";
                // debugger;
                mind = getEmptyMap(mindmapKey);
            }
            const modJsmindDraggable = await import("/ext/jsmind/chrome-src-jsmind.draggable-node.js");
            modJsmindDraggable.setupNewDragging();

            const jmDisplayed = displayMindMap(mind);

            // getJmnodes(jmDisplayed).addEventListener("dblclick", async evt =>)
            async function jmnodeDblclick(evt) {
                const target = evt.target;
                let eltJmnode = target;
                const tn = target.tagName;
                if (tn !== "JMNODE") {
                    eltJmnode = target.closest("jmnode");
                }
                evt.preventDefault();
                evt.stopPropagation();
                evt.stopImmediatePropagation();
                const modMdc = await import("/src/js/mod/util-mdc.js");
                const eltCopied = eltJmnode.cloneNode(true);
                eltCopied.style.top = 0;
                eltCopied.style.left = 0;

                // https://css-tricks.com/almanac/properties/r/resize/
                eltCopied.style.overflow = "auto";
                // eltCopied.style.resize = "both";
                // eltCopied.style.border = "1px solid red";
                // eltCopied.style.borderRadius = 0;
                eltCopied.draggable = null;

                const copiedWpx = eltCopied.style.width;
                const copiedHpx = eltCopied.style.height;
                const copiedW = parseInt(copiedWpx);
                const copiedH = parseInt(copiedHpx);

                /* 
                    css resize does not work well on Android Chrome today (2023-05-01).
                    Add a workaround using pointerdown, -move and -up.
                    https://javascript.info/pointer-events
                    https://plnkr.co/edit/zSi5dCJOiabaCHfw?p=preview&preview
                */
                const divCopied = mkElt("div", undefined, [
                    mkElt("jmnodes", undefined, eltCopied)
                ]);
                divCopied.style.position = "relative";
                divCopied.style.height = "200px";
                divCopied.style.width = "100%";
                // https://stackoverflow.com/questions/59010779/pointer-event-issue-pointercancel-with-pressure-input-pen
                divCopied.style.touchAction = "none";
                const body = mkElt("div", undefined, [
                    mkElt("h2", undefined, "Edit"),
                    divCopied,
                ]);


                // The workaround:
                const thumbSize = "50";
                const style = [
                    "background:red",
                    `width:${thumbSize}px`,
                    `height:${thumbSize}px`,
                    "position:fixed",
                    "left:0",
                    "top:0",
                    "z-index:10"
                ].join(";");
                const thumb = mkElt("span", { style },
                    2
                );
                divCopied.appendChild(thumb);
                let bcrC, bcrT;
                setTimeout(() => {
                    bcrC = eltCopied.getBoundingClientRect();
                    bcrT = thumb.getBoundingClientRect();
                    thumb.style.left = bcrC.left + bcrC.width - bcrT.width / 2 + "px";
                    thumb.style.top = bcrC.top + bcrC.height + - bcrT.height / 2 + "px";
                }, 100);

                let shiftX, shiftY;
                let startX, startY;
                let newBcrC;
                function onThumbDown(evts) {
                    console.log("onThumbDown", { evts });
                    evts.preventDefault(); // prevent selection start (browser action)

                    const bcrThumb = thumb.getBoundingClientRect();
                    const evt = evts[0] || evts;
                    startX = evt.clientX;
                    startY = evt.clientY;
                    shiftX = startX - bcrThumb.left;
                    shiftY = startY - bcrThumb.top;

                    thumb.setPointerCapture(evts.pointerId);
                    thumb.onpointermove = onThumbMove;
                    // thumb.onpointerout = (evt) => console.warn("pointerout", evt);
                    // thumb.onpointerleave = (evt) => console.warn("pointerleave", evt);
                    // thumb.onpointerenter = (evt) => console.warn("pointerenter", evt);
                    // thumb.onpointercancel = (evt) => console.warn("pointercancel", evt);
                    thumb.onpointerup = evts => {
                        console.log("onpointerup", { evts });
                        thumb.onpointermove = null;
                        thumb.onpointerup = null;
                        newBcrC = eltCopied.getBoundingClientRect();
                    }
                };

                let n = 0;
                function onThumbMove(evts) {
                    const target = evts.target;
                    const evt = evts[0] || evts;
                    const nowX = evt.clientX;
                    const nowY = evt.clientY;
                    thumb.style.left = nowX - shiftX + 'px';
                    thumb.style.top = nowY - shiftY + 'px';
                    const diffLeft = nowX - startX;
                    const diffTop = nowY - startY;
                    // return;
                    eltCopied.style.width = bcrC.width + diffLeft + "px";
                    eltCopied.style.height = bcrC.height + diffTop + "px";
                };

                thumb.onpointerdown = onThumbDown;
                thumb.ondragstart = () => false;

                const res = await modMdc.mkMDCdialogConfirm(body, "save", "cancel");
                console.log({ res });
                if (res) {
                    // const eltCopied = eltJmnode.cloneNode(true);
                    const node_id = getNodeIdFromDOMelt(eltJmnode);
                    jmDisplayed.set_node_background_image(node_id, "none", newBcrC.width, newBcrC.height);
                    // savethis
                    DBsaveThisMindmap(jmDisplayed);
                    updateJmnodeFromFc4i(eltJmnode);
                }
            }


            jmDisplayed.add_event_listener((type, data) => {
                if (type !== 3) return;
                const evt = data.evt;
                const datadata = data.data;
                const node_id = data.node;
                console.log({ evt, type, datadata, data });
                switch (evt) {
                    case "add_node":
                        // const id_parent = datadata[0];
                        // const id_added = data.node;
                        const id_added = node_id;
                        // const id_added = datadata[1];
                        // const topic = datadata[2];
                        const added_node = jmDisplayed.get_node(id_added);
                        const fc4i_added = added_node.data.fc4i;
                        console.log({ id_added, added_node, fc4i_added });
                        // console.log({ evt, id_parent, id_added, topic, added_node, fc4i_added });
                        break;
                    case "update_node":
                        // const id_updated = data.node;
                        const id_updated = node_id;
                        const updated_node = jmDisplayed.get_node(id_updated);
                        const fc4i_updated = updated_node.data.fc4i;
                        console.log({ evt, id_updated, fc4i_updated, updated_node });
                        if (!!fc4i_updated) {
                            updateJmnodeFromFc4i(jsMind.my_get_DOM_element_from_node(updated_node));
                        }
                        break;
                    case "move_node":
                        function walkMoved(id_moved) {
                            console.log({ id_moved });
                            const moved_node = jmDisplayed.get_node(id_moved);
                            moved_node.children.forEach(child => {
                                walkMoved(child.id);
                            });
                        }
                        // const id_moved = datadata[0];
                        const id_moved = node_id;
                        const moved_node = jmDisplayed.get_node(id_moved);
                        const fc4i_moved = moved_node.data.fc4i;
                        console.log({ evt, id_moved, fc4i_moved, });
                        // FIX-ME: It does not look as we need to walk the tree????
                        // walkMoved(id_moved);
                        let update = false;
                        update = true;
                        // if (update && !!fc4i_moved) updateJmnodeFromFc4i(moved_node._data.view.element);
                        if (update && !!fc4i_moved) updateJmnodeFromFc4i(jsMind.my_get_DOM_element_from_node(moved_node));
                        break;
                    case "remove_node":
                        break;
                    default:
                        console.warn(`unknown evt: ${evt}`);
                }
                DBsaveThisMindmap(jmDisplayed); // FIX-ME: delay
            });
            // FIX-ME: remove when this is fixed in jsmind.
            setTimeout(() => {
                [...document.getElementsByTagName("jmnode")].forEach(eltJmnode => {
                    if (eltJmnode.getAttribute("nodeid") === "root") return;
                    console.log("old eltJmnode.draggable", eltJmnode.draggable);
                    eltJmnode.draggable = true;
                    const child1 = eltJmnode.firstElementChild;
                    if (child1 && child1.tagName === "DIV" && child1.classList.contains("fc4i")) {
                        updateJmnodeFromFc4i(eltJmnode);
                    }
                });
            }, 500);

            jsMindContainer.appendChild(divDebugLog);

            const idContextMenu = "jsmind-context-menu";
            let divContextMenu;

            async function getDivContextMenu() {
                if (!divContextMenu) {
                    const modMdc = await import("/src/js/mod/util-mdc.js");
                    divContextMenu = modMdc.mkMDCmenuDiv();
                    divContextMenu.classList.add("is-menu-div");
                    document.body.appendChild(divContextMenu);
                    divContextMenu.id = idContextMenu;
                }
                return divContextMenu;
            }
            let highestNodeId = 0;
            jmDisplayed.enable_edit();
            const jmData = jmDisplayed.get_data("node_array");
            jmData.data.forEach(entry => {
                // if (entry.id === "root") return;
                if (!Number.isInteger(entry.id)) return;
                highestNodeId = Math.max(+entry.id, highestNodeId);
            });
            function getNextNodeId() { return ++highestNodeId; }

            // FIX-ME: The node does not get DOM focus???
            function focusSelectedNode() {
                const selectedNode = jmDisplayed.get_selected_node();
                if (selectedNode) {
                    const selectedElt = getDOMeltFromNode(selectedNode);
                    selectedElt.focus();
                }
            }
            function hideContextMenu() {
                if (!divContextMenu) return;
                divContextMenu.style.display = "none";
                setTimeout(focusSelectedNode, 2000);
            }
            function hideContextMenuOnEvent(evt) {
                if (!divContextMenu) return;
                if (!targetIsJmnode(evt) && !divContextMenu.contains(evt.target)) hideContextMenu();
            }

            // These bubbles up:
            jsMindContainer.addEventListener("mousedown", evt => hideContextMenuOnEvent(evt));
            jsMindContainer.addEventListener("keydown", evt => hideContextMenuOnEvent(evt));
            jsMindContainer.addEventListener("touchstart", evt => hideContextMenuOnEvent(evt));
            jsMindContainer.addEventListener("click", evt => hideContextMenuOnEvent(evt));
            jsMindContainer.addEventListener("click", evt => {
                // evt.stopPropagation();
                // evt.preventDefault();
                const target = evt.target;
                // eltFc4iLink.dataset.fc4iEntryLink = "true";
                if (target.dataset.fc4iEntryLink === "true") {
                    const eltJmnode = target.closest("jmnode");
                    if (eltJmnode) {
                        const node_id = getNodeIdFromDOMelt(eltJmnode);
                        jmDisplayed.select_node(node_id);
                    }
                    setTimeout(() => {
                        const go = confirm("Show entry in fc4i?");
                        console.log({ go });
                        if (go) alert("Not implemented yet");
                    }, 100);
                };
            });

            function displayContextMenuOnContainer(evt) {
                evt.preventDefault();
                evt.stopPropagation();

                // FIX-ME: move
                // document.querySelectorAll("jmnode").forEach(n => n.draggable = true);

                displayContextMenu(jsMindContainer, evt.clientX, evt.clientY);
            }

            let msDelayContextMenu = 0;
            jsMindContainer.addEventListener("NOtouchmove", evt => {
                // evt.preventDefault();
                evt.stopPropagation();
                stopContextMenu();
            });
            jsMindContainer.addEventListener("NOtouchstart", evt => {
                const jmnode = targetIsJmnode(evt);
                if (jmnode) {
                    evt.stopPropagation();
                    msDelayContextMenu = 1000;
                    jmDisplayed.select_node(jmnode);
                }
            });
            jsMindContainer.addEventListener("NOcontextmenu", evt => {
                if (targetIsJmnode(evt)) {
                    evt.preventDefault();
                    const x = `${evt.clientX}`;
                    const y = `${evt.clientY}`;
                    restartDisplayContextMenu(evt.target, x, y);
                }
            });

            function targetIsJmnode(evt) {
                const targ = evt.target;
                const jmnode = targ.closest("jmnode");
                return jmnode;
            }
            function stopContextMenu() { restartDisplayContextMenu(); }
            const restartDisplayContextMenu = (() => {
                let tmr;
                return (forElt, x, y) => {
                    clearTimeout(tmr);
                    if (forElt === undefined) return;
                    // if (x === undefined) return;
                    // if (divContextMenu.style.display === "block") return;
                    // if (divContextMenu?.forElt === forElt) return;
                    const doDisplay = () => displayContextMenu(forElt, x, y);
                    tmr = setTimeout(doDisplay, msDelayContextMenu);
                }
            })();


            async function displayContextMenu(forElt, left, top) {
                const divMenu = await getDivContextMenu();
                await mkContextMenu();
                divMenu.forElt = forElt;
                // Set values in integer, read them as ..px
                divMenu.style.left = left;
                divMenu.style.top = top;
                divMenu.style.opacity = 0;
                divMenu.style.display = "block";
                const compStyle = getComputedStyle(divMenu);

                const right = parseInt(compStyle.right);
                // console.log({ right });
                // FIX-ME: This is fragile. Chrome tries to wrap the menu.
                if (right <= 0) divMenu.style.left = parseInt(divMenu.style.left) + right - 30;

                const bottom = parseInt(compStyle.bottom);
                // console.log({ bottom });
                if (bottom < 0) divMenu.style.top = parseInt(divMenu.style.top) + bottom;

                divMenu.style.opacity = 1;
            }


            async function mkContextMenu() {
                const modMdc = await import("/src/js/mod/util-mdc.js");
                const selNode = jmDisplayed.get_selected_node();
                // console.log({ selNode });

                function checkSelected() {
                    if (!selNode) {
                        modMdc.mkMDCdialogAlert("No selected node");
                        return false;
                    }
                    return selNode;
                }
                function markIfNoSelected(li) {
                    if (selNode) return;
                    li.classList.add("jsmind-menu-no-selected-node");
                }
                function markIfNoMother(li) {
                    if (selNode?.parent) return;
                    li.classList.add("jsmind-menu-no-selected-node");
                }

                function mkMenuItem(lbl, fun) {
                    const li = modMdc.mkMDCmenuItem(lbl);
                    li.addEventListener("click", evt => {
                        evt.preventDefault();
                        evt.stopPropagation();
                        fun();
                        hideContextMenu();
                    });
                    return li;
                }

                const liTestTabindex = mkMenuItem("Test tabindex=1",
                    () => {
                        document.querySelectorAll("jmnode").forEach(jmn => {
                            jmn.setAttribute("tabindex", "1");
                        })
                    }
                );
                const liTestSvgDrawLine = mkMenuItem("Test svg draw line",
                    () => { testSvgLine(); }
                );

                const liTestTouch = mkMenuItem("Test for touch",
                    () => {
                        const hasTouch = hasTouchEvents();
                        addDebugLog(`Has touch: ${hasTouch}`);
                    });
                const liTestMouse = mkMenuItem("Test for mouse",
                    // https://stackoverflow.com/questions/21054126/how-to-detect-if-a-device-has-mouse-support/50687322#50687322
                    // https://bugs.chromium.org/p/chromium/issues/detail?id=1088262
                    () => {
                        const hasCursor = window.matchMedia('(pointer:fine)').matches;
                        addDebugLog(
                            `window.matchMedia('(pointer:fine)').matches; ${hasCursor}`
                        );
                    });

                // const liSaveTestmap = mkMenuItem("Save test mindmap", setTestMindmap)
                // const liGetTestmap = mkMenuItem("Get test mindmap", getTestMindmap);

                const liRemoveCanvas = mkMenuItem("remove canvas", lookForCanvas);

                const liAddChild = mkMenuItem("Add child", () => addNode("child"));
                markIfNoSelected(liAddChild);

                const liAddSibling = mkMenuItem("Add sibling", () => addNode("brother"));
                markIfNoSelected(liAddSibling);
                markIfNoMother(liAddSibling);

                function addNode(rel) {
                    const selectedNode = checkSelected();
                    if (selectedNode) {
                        const jm = jsMind.current;
                        const nodeId = getNextNodeId();
                        let newNode;
                        switch (rel) {
                            case "child":
                                newNode = jm.add_node(selectedNode, nodeId, `Node ${nodeId}`);
                                break;
                            case "brother":
                                const mother = selectedNode.parent;
                                if (!mother) {
                                    modMdc.mkMDCdialogAlert("This node can't have siblings");
                                } else {
                                    newNode = jm.add_node(mother, nodeId, `Node ${nodeId}`);
                                }
                                break;
                        }
                        // setTimeout(() => { newNode._data.view.element.draggable = true; }, 1000);
                        setTimeout(() => { jsMind.my_get_DOM_element_from_node(newNode).draggable = true; }, 1000);
                    }
                }

                const liDelete = mkMenuItem("Delete node", deleteNode);
                markIfNoSelected(liDelete);
                markIfNoMother(liDelete);

                function deleteNode() {
                    const selectedNode = checkSelected();
                    if (selectedNode) {
                        const mother = selectedNode.parent;
                        if (!mother) {
                            modMdc.mkMDCdialogAlert("This node can't be deleted");
                        } else {
                            const jm = jsMind.current;
                            jm.remove_node(selectedNode);
                            // setTestMindmap();
                        }
                    }
                    hideContextMenu();
                }

                const arrEntries = [
                    // liTestAlert,
                    // liRemoveCanvas,
                    liAddChild,
                    liAddSibling,
                    liDelete,
                    // liSaveTestmap,
                    liTestTouch,
                    liTestMouse,
                    liTestSvgDrawLine,
                    liTestTabindex,
                ];
                if (document.querySelector("canvas")) { arrEntries.push(liRemoveCanvas); }
                const ulMenu = modMdc.mkMDCmenuUl(arrEntries);
                const divMenu = await getDivContextMenu();
                divMenu.textContent = "";
                divMenu.appendChild(ulMenu);
                return divMenu;
            }
            function displayMindMap(mind) {
                const options = {
                    container: 'jsmind_container',
                    theme: 'orange',
                    editable: true,
                    view: {
                        // draggable: true,
                        draggable: false,
                        hide_scrollbars_when_draggable: false,
                        engine: "svg",
                        line_width: 10,
                        line_color: "green",
                    },
                    shortcut: {
                        enable: true, 		// whether to enable shortcut
                        handles: {}, 			// Named shortcut key event processor
                        mapping: { 			// shortcut key mapping
                            addchild: [45, 4096 + 13], 	// <Insert>, <Ctrl> + <Enter>
                            addbrother: 13, // <Enter>
                            editnode: 113, 	// <F2>
                            delnode: 46, 	// <Delete>
                            toggle: 32, 	// <Space>
                            left: 37, 		// <Left>
                            up: 38, 		// <Up>
                            right: 39, 		// <Right>
                            down: 40, 		// <Down>
                        }
                    },
                };
                const jm = new jsMind(options);
                jm.show(mind);
                // jm.my_get_DOM_element_from_node = (node) => { return node._data.view.element; }
                return jm;
            }

            addScrollIntoViewOnSelect();
            function addScrollIntoViewOnSelect() {
                jmDisplayed.add_event_listener(function (t, d) {
                    // console.log({ t, d });
                    if (t !== jsMind.event_type.select) return;
                    const id = d.node;
                    const n = jmDisplayed.get_node(id);
                    // const elt = n._data.view.element;
                    const elt = jsMind.my_get_DOM_element_from_node(n);

                    // FIX-ME: test .scrollIntoView - works fine
                    const scrollOpt = { behavior: "smooth" };
                    // console.log({scrollOpt})
                    elt.scrollIntoView(scrollOpt);
                    return;

                    const cr = elt.getBoundingClientRect(elt);
                    const crLeft = cr.left;
                    const crRight = cr.right;
                    // console.log({ t, d, id, elt, cr });
                    const eltScroll = jsMindContainer.firstElementChild;
                    if (crLeft < 0) {
                        eltScroll.scrollBy(crLeft, 0);
                    } else {
                        const overRight = crRight - jsMindContainer.clientWidth;
                        if (overRight > 0) {
                            eltScroll.scrollBy(overRight, 0);
                        }
                    }
                    // FIX-ME: vertical
                });
            }
            function jsmindSearchNodes(strSearch) {
                console.log("jsmindSearch", { strSearch });
                /*
                const nodeArray = jm.get_data("node_array");
                const nodes = nodeArray.data;
                console.log({ nodes });
                const mathingNodes = nodes.filter(node => {
                    const topic = node.topic;
                    console.log({ topic });
                    return topic.indexOf(strSearch) >= 0;
                });
                */
                const nodeEltArray = [...jsMindContainer.querySelectorAll("jmnode[nodeid]")];
                nodeEltArray.forEach(n => n.classList.remove("jsmind-search-match"));
                console.log({ nodeEltArray });
                if (strSearch.length === 0) return;
                const searchLower = strSearch.toLocaleLowerCase();
                const matchingNodes = nodeEltArray.filter(node => {
                    const topic = node.textContent;
                    console.log({ node, topic });
                    const topicLower = topic.toLocaleLowerCase();
                    return topicLower.indexOf(searchLower) >= 0;
                });
                matchingNodes.forEach(n => n.classList.add("jsmind-search-match"));
                console.log({ matchingNodes });
            }

            /*
            function setTestMindmap() {
                console.error("called setTestMindMap");
                throw Error("called setTestMindMap");
                const mind = jmDisplayed.get_data("node_array");
                const mindmapName = mind.meta.name;
                if (!mindmapName) throw Error("Current mindmap has no meta.name");
                DBsetMindmap(mindmapName, mind);
            }
            function getTestMindmap(mindmapName) {
                console.error("called getTestMindMap");
                throw Error("called getTestMindMap");
                return DBgetMindmap(mindmapName);
            }
            function removeMind() {
                console.error("called removeMind");
                throw Error("called removeMind");
                // localStorage.removeItem(lsMindKey);
                const mind = jmDisplayed.get_data("node_array");
                const mindmapName = mind.meta.name;
                DBremoveMindmap(mindmapName);
            }
            */


            function onMousemoveJmnode(evt) {
                if (evt.target.nodeName !== "JMNODE") return;
                console.log("ddrag", { evt });
            }

            jmDisplayed.select_node(jmDisplayed.get_root());

            function rectDist(br1, br2) {
                const brLeft = br1.left < br2.left ? br1 : br2;
                const brRight = br1.right > br2.right ? br1 : br2;
                const overLapHor = brLeft.right > brRight.left;
                const brTop = br1.top < br2.top ? br1 : br2;
                const brBottom = br1.bottom > br2.bottom ? br1 : br2;
                const overLapVer = brTop.bottom > brBottom.top;
                if (overLapHor && overLapVer) return 0;
                if (overLapHor) { return brTop.bottom - brBottom.top; }
                if (overLapVer) { return brRight.left - brLeft.right; }
                const w = brLeft.right - brRight.left;
                const h = brTop.bottom - brBottom.top;
                return Math.sqrt(h * h + w * w);
            }

            if (!hasTouchEvents()) addGrabAndScroll2jsmind();
            function addGrabAndScroll2jsmind() {
                // const root = jmDisplayed.get_root();
                // const eltRoot = getDOMeltFromNode(root);
                // const jmnodes = eltRoot.closest("jmnodes");
                const jmnodes = getJmnodes(jmDisplayed);
                const jsmindInner = jmnodes.closest(".jsmind-inner");
                // const jsmindInner = jsMindContainer.firstElementChild;
                // const jsmindInner = jsMindContainer.querySelector(".jsmind-inner");
                if (!jsmindInner.classList.contains("jsmind-inner")) {
                    throw Error("Not jsmind-inner");
                }
                addGrabAndScroll(jsmindInner, jmnodes);
            }

            function addGrabAndScroll(ele, mousedownTargets) {
                // https://htmldom.dev/drag-to-scroll/
                /* .container { cursor: grab; overflow: auto; } */
                let posScrollData;

                const isMousedownTarget = (targ) => {
                    if (Array.isArray(mousedownTargets)) {
                        return mousedownTargets.includes(targ);
                    } else {
                        return targ === mousedownTargets;
                    }
                    return false;
                }
                const mouseDownHandler = (evt) => {
                    // console.log("ele mousedown");
                    if (!isMousedownTarget(evt.target)) {
                        // console.log("not mousedown target");
                        return;
                    }
                    evt.preventDefault();
                    evt.stopPropagation();
                    // mouseDownHandler2();
                    // Change the cursor and prevent user from selecting the text
                    posScrollData = {
                        // The current scroll
                        left: ele.scrollLeft,
                        top: ele.scrollTop,
                        // Get the current mouse position
                        x: evt.clientX,
                        y: evt.clientY,
                    };
                    ele.style.cursor = "grabbing";
                    // console.log("mouseDownHandler", ele.style.cursor);

                    ele.addEventListener('mousemove', mouseMoveHandler);
                    ele.addEventListener('mouseup', mouseUpHandler);
                    ele.addEventListener("mouseleave", mouseUpHandler);
                };
                const mouseMoveHandler = (evt) => {
                    // How far the mouse has been moved
                    const dx = evt.clientX - posScrollData.x;
                    const dy = evt.clientY - posScrollData.y;
                    // console.log("mouseMoveHandler dx, dy, .scrollLeft", dx, dy, ele.scrollLeft, posScrollData);

                    // Scroll the element
                    ele.scrollTop = posScrollData.top - dy;
                    ele.scrollLeft = posScrollData.left - dx;
                };
                const mouseUpHandler = function () {
                    // console.log("ele mouseup");
                    ele.removeEventListener('mousemove', mouseMoveHandler);
                    ele.removeEventListener('mouseup', mouseUpHandler);

                    ele.style.cursor = 'grab';
                    // console.log("mouseUpHandler", ele.style.cursor);
                    ele.style.removeProperty('user-select');
                };

                const showDraggable = () => {
                    // Change the cursor and prevent user from selecting the text
                    ele.style.cursor = 'grab';
                    // console.log("showDraggable", ele.style.cursor);
                    ele.style.userSelect = 'none';
                };
                ele.addEventListener("mousedown", mouseDownHandler);
                // ele.addEventListener("dragstart", mouseUpHandler);
                showDraggable();

            }

            // https://javascript.info/bezier-curve
            /*
                For 4 control points:
                P = (1−t)3P1 + 3(1−t)2tP2 +3(1−t)t2P3 + t3P4
            */
            function makePoint(x, y) { return { x, y } }
            function isPoint(xy) {
                return !isNaN(xy.x) && !isNaN(xy.y);
            }
            function bezier(t, p1, p2, p3, p4) {
                check01(t);
                function check01(what, v) {
                    if (v < 0) throw Error(`${what} < 0 (${v})`);
                    if (v > 1) throw Error(`${what} > 1 (${v})`);
                }

            }

            function pasteCopied4Mindmap() {
                const keyCopied = getJsmindCopied4Mindmap();
                // removeJsmindCopied4Mindmap();
                console.log({ keyCopied });
                // debugger;
                if (keyCopied === null) return;
                const root_id = jmDisplayed.get_root().id;
                const node_data = {
                    info: "This is just a test",
                    fc4i: keyCopied
                }
                const old_node = jmDisplayed.get_node(keyCopied);
                if (old_node) {
                    jmDisplayed.select_node(old_node);
                    setTimeout(() => alert("Not added because node already exists"));
                    return;
                }
                // getNext
                const new_id = getNextNodeId();
                // const new_node = jmDisplayed.add_node(root_id, keyCopied, "RMINDER", node_data);
                const new_node = jmDisplayed.add_node(root_id, new_id, "RMINDER", node_data);
                fixNewFc4iNode(new_node.id);
                jmDisplayed.select_node(new_node);
                // setTestMindmap();
            }
            pasteCopied4Mindmap();

            async function fixNewFc4iNode(node_id) {
                const node = jmDisplayed.get_node(node_id);
                const fc4iKey = node.data.fc4i;
                console.log(fc4iKey);
                const html = mkElt("div", { class: "fc4i" }, [
                    mkElt("div", { class: "fc4i-title" }),
                    mkElt("div", { class: "fc4i-image" })
                ]);
                html.dataset["fc4i"] = fc4iKey;
                const style = [
                    "position:absolute",
                    "bottom:0",
                    "right:0",
                    "background:red",
                    "width:48px",
                    "height:48px",
                    `background-image:url(/img/192.png)`,
                    "background-size:cover"
                ].join(";");
                const eltFc4iLink = mkElt("div", { style });
                eltFc4iLink.dataset.fc4iEntryLink = "true";
                jmDisplayed.update_node(node, html.outerHTML + eltFc4iLink.outerHTML);
                jmDisplayed.set_node_background_image(node_id, "none", 150, 100);
                // setTimeout(() => { finishUpdate(); }, 0);
                // const eltJmnode = getDOMeltFromNode(node);
                const NOfinishUpdate = () => {
                    const eltJmnode = getDOMeltFromNode(node);
                    updateJmnodeFromFc4i(eltJmnode);
                }
            }
            async function updateJmnodeFromFc4i(eltJmnode) {
                const tn = eltJmnode.tagName;
                if (tn !== "JMNODE") throw Error(`Not a <jmnode>: ${tn}`)
                eltJmnode.removeEventListener("dblclick", jmnodeDblclick);
                eltJmnode.addEventListener("dblclick", jmnodeDblclick);
                const html = eltJmnode.firstElementChild;
                html.addEventListener("click", evt => {
                    console.log("clicked", eltJmnode);
                    // Did not work:
                    // eltJmnode.click(evt);
                    const node_id = getNodeIdFromDOMelt(eltJmnode);
                    jmDisplayed.select_node(node_id);
                });
                // debugger;
                const key = html.dataset.fc4i;
                if (!key) throw Error("No fc4i key found on <jmnode>")
                const keyRec = await get1Reminder(key);
                html.firstElementChild.textContent = keyRec.title;
                if (keyRec.images && (keyRec.images.length > 0)) {
                    const blob = keyRec.images[0];
                    const urlBlob = URL.createObjectURL(blob);
                    const eltHtmlImg = html.lastElementChild;
                    const style = eltHtmlImg.style;
                    const urlBg = `url(${urlBlob})`;
                    style.backgroundImage = urlBg;
                }
            }

            function updateAllFc4i() {
                // const root_node = jmDisplayed.get_root();
                // const eltRoot = getDOMeltFromNode(root_node);
                // const eltJmnodes = eltRoot.closest("jmnodes");
                const eltJmnodes = getJmnodes(jmDisplayed);
                eltJmnodes.querySelectorAll("jmnode > div.fc4i")
                    .forEach(async fc => {
                        const eltJmnode = fc.parentElement;
                        // const key = fc.dataset.fc4i;
                        // const keyRec = await get1Reminder(key);
                        // console.log({ eltJmnode, keyRec });
                        updateJmnodeFromFc4i(eltJmnode);
                    });
            }

            let moFc4i;
            // addMutationObserver();
            function addMutationObserver() {
                const eltJmnodes = getJmnodes(jmDisplayed);
                moFc4i = new MutationObserver(mutrec => {
                    console.log(mutrec);
                    // FIX-ME: loop over mutrec??
                    const mr = mutrec[0];
                    const rN = mr.removedNodes;
                    console.log({ mr, rN });
                    if (rN && rN.length > 0) {
                        const eltR0 = rN[0];
                        const tn = eltR0.tagName;
                        console.log({ tn });
                        if (tn === "DIV") {
                            const isFc4i = eltR0.classList.contains("fc4i");
                            // console.log({ eltR0, isFc4i });
                            if (isFc4i) {
                                const eltA0 = mr.addedNodes[0];
                                // console.log({ eltA0 });
                                const eltJmnode = eltA0.closest("jmnode");
                                // console.log({ eltJmnode });
                                updateJmnodeFromFc4i(eltJmnode);
                            }
                        }
                    }
                });
                moFc4i.observe(eltJmnodes, { childList: true, subtree: true });
            }
        }

        function hasTouchEvents() {
            let hasTouch = false;
            try {
                document.createEvent("TouchEvent");
                hasTouch = true;
            } catch (e) { }
            console.warn({ hasTouch })
            return hasTouch;

        }

        ///////////////////////////////////////////////
        // Utility functions. FIX-ME: Should be in jsmind core

        // function getDOMeltFromNode(node) { return node._data.view.element; }
        function getDOMeltFromNode(node) { return jsMind.my_get_DOM_element_from_node(node); }
        function getNodeIdFromDOMelt(elt) {
            const tn = elt.tagName;
            if (tn !== "JMNODE") throw Error(`Not jmnode: <${tn}>`);
            const id = elt.getAttribute("nodeid");
            if (!!!id) throw Error("Could not find jmnode id");
            return id;
        }
        function getJmnodes(jmDisplayed) {
            const root_node = jmDisplayed.get_root();
            const eltRoot = jsMind.my_get_DOM_element_from_node(root_node);
            const eltJmnodes = eltRoot.closest("jmnodes");
            return eltJmnodes;
        }

    </script>
</body>

</html>